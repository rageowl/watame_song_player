<html>
	<title>Watame's Song Player</title>
	<meta charset="UTF-8">
	<script type="text/javascript" charset="utf-8">
var playingList = undefined
var playListData = undefined
var individualVolumeData = undefined
const SheetHeader = "http://spreadsheets.google.com/tq?key="
let defaultClipSpreadSheetURL = ['1vpbCjP0UorTAiEHx9sOTGF1oNfpwW1jIZ6v1npQExEk']
var settingsData = { clipSpreadSheetURL:defaultClipSpreadSheetURL }
	</script>
	<script src="https://www.gstatic.com/charts/loader.js"></script>
	<script type="text/javascript" charset="utf-8">
let videoClipList = []
	</script>
	<style>
		.tblWrap {
			display:flex;
			flex-direction: column;
			overflow: auto;
		}
		.userTblHead {
			flex: none;
			overflow-x: hidden;
		}
		.userTbl {
			flex: 1;
			overflow: auto;
		}
		.tblWrap table {
			width: 100%;
			border-spacing: 0;
			border-width: 1px 0;
			border-collapse: collapse;
			table-layout: fixed;
		}
		.tblWrap table thead th {
			background: #eee;
		}
		.tblWrap table tr {
			border-bottom: 1px solid #aaa;
			height:20px;
			text-align: center;
		}
		.tblWrap table td {
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			text-overflow: ellipsis;
			white-space: nowrap;
			overflow: hidden;
		}
		.tblWrap table td.left {
			text-align: left;
			padding-left: 10px;
		}
		.tblWrap table th:not(:last-child), table td:not(:last-child) {
			border-right: solid 1px #aaa;
		}
		.userTbl[dragHover="1"] {
			outline: solid #1E90FF;
		}
		.userTbl table {
			font-size:14px;
			border-top: 0px;
		}
		.userTblHead table {
			overflow: hidden;
			border-top: 2px solid #aaa;
			border-bottom: 1px solid #aaa;
		}
		.userTblHead table td[dragHover="1"] {
			color: black;
			background: linear-gradient(to right, #1E90FF 20%, transparent 20%);
		}
		.userTblHead table td[dragHover="2"] {
			color: black;
			background: linear-gradient(to left, #1E90FF 20%, transparent 20%);
		}
		.userTbl table tr[selected="true"] {
			color: #FFFFFF;
			background: #1E90FF;
		}
		.userTbl table tr[dragHover="1"] {
			color: black;
			background: linear-gradient(#1E90FF 40%, white 40%);
		}
		.userTbl table tr[dragHover="2"] {
			color: black;
			background: linear-gradient(white 60%, #1E90FF 60%);
		}
		.userTbl table tr[dragHover="3"] {
			color: black;
			background: linear-gradient(white 20%, #1E90FF 20% 80%, white 80%);
		}
		.contextMenuDiv {
			display:flex;
			flex-direction: column;
			background: white;
			width: 200px;
			box-shadow:1px 1px 3px 1px;
		}
		.contextMenuDivItemNormal {
			display:flex;
			padding:4px 0 0 4px;
			user-select: none;
		}
		.contextMenuDivItemHover {
			display:flex;
			padding:4px 0 0 4px;
			user-select: none;
			background: #E8E8E8;
		}
	</style>
	<head>
		<script type="text/javascript" charset="utf-8">
class DivBase {
	constructor() {
		let div = document.createElement('div')
		this.div = div
	}
	get className() {
		return this.div.className
	}
	set className(name) {
		this.div.className = name
	}
	getBoundingClientRect() {
		return this.div.getBoundingClientRect()
	}
}
class PopupMenuItem extends DivBase {
	constructor(menu) {
		super();
		this.menu = menu
		this.normalClassName = menu.itemNormalClassName
		this.hoverClassName = menu.itemHoverClassName
		this.subMenu = null
		this.div.className = this.normalClassName
		this.subMenuOffsetX = menu.subMenuOffsetX
		
		let obj = this
		this.div.addEventListener('mouseenter', function(event) {
			obj.div.className = obj.hoverClassName
			if (obj.subMenu) {
				if (obj.subMenu.isWaitingDismiss) {
					obj.subMenu.cancelDismiss()
				} else {
					obj.subMenuTimeoutID = setTimeout(function(){
						obj.subMenuTimeoutID = undefined
						obj.showMenu()
					}, 500);
				}
				obj.subMenu.incEnterCounter(1)
			}
		})
		this.div.addEventListener('mouseleave', function(event) {
			obj.div.className = obj.normalClassName
			if (obj.subMenu) {
				if (obj.subMenuTimeoutID) {
					clearTimeout(obj.subMenuTimeoutID)
					obj.subMenuTimeoutID = undefined
				} else {
					obj.subMenu.reserveDismiss(true)
				}
				obj.subMenu.incEnterCounter(-1)
			}
		})
		this.div.addEventListener('click', function(event) {
			if (obj.subMenu) {
				if (obj.subMenuTimeoutID) {
					clearTimeout(obj.subMenuTimeoutID)
					obj.subMenuTimeoutID = undefined
				}
				obj.showMenu()
			} else {
				if (obj.onclick) {
					obj.onclick(event)
				}
				let parent = obj.menu
				while (parent.parent) {
					parent = parent.parent
				}
				parent.dismiss()
			}
		})
	}
	showMenu() {
		let rect = this.div.getBoundingClientRect()
		if (!this.menu.showSubmenuLeft) {
			this.subMenu.showSubmenuLeft = false
			this.subMenu.show(rect.right - this.subMenuOffsetX, rect.top, false)
		
			let subRect = this.subMenu.getBoundingClientRect()
			if (subRect.right > window.innerWidth) {
				this.subMenu.showSubmenuLeft = true
				this.subMenu.show(rect.left + this.subMenuOffsetX, rect.top, false, 1, 0)
			}
		} else {
			this.subMenu.showSubmenuLeft = true
			this.subMenu.show(rect.left + this.subMenuOffsetX, rect.top, false, 1, 0)
			let subRect = this.subMenu.getBoundingClientRect()
			if (subRect.left < 0) {
				this.subMenu.showSubmenuLeft = false
				this.subMenu.show(rect.right - this.subMenuOffsetX, rect.top, false)
			}
		}
	}
	setElements(...elements) {
		this.div.replaceChildren(...elements)
	}
	setSubMenu() {
		let subMenu = new PopupMenu(this.menu)
		this.subMenu = subMenu
		return subMenu
	}
}
class PopupMenu extends DivBase {
	constructor(parent=null) {
		super();
		this.dismissOnMouseLeave = false
		this.itemNormalClassName = ''
		this.itemHoverClassName = ''
		this.parent = parent
		this.subMenuOffsetX = 2
		this.mouseEnterCounter = 0
		this.showSubmenuLeft = false
		if (parent) {
			this.className = parent.className
			this.itemNormalClassName = parent.itemNormalClassName
			this.itemHoverClassName = parent.itemHoverClassName
			this.subMenuOffsetX = parent.subMenuOffsetX
			this.showSubmenuLeft = parent.showSubmenuLeft
		}
		this.child = null
		document.body.appendChild(this.div);
		let style = this.div.style
		style.display = 'none'
		style.position = 'absolute'
		
		let obj = this
		this.div.addEventListener('mouseenter', function(event) {
			obj.incEnterCounter(1)
			if (obj.dismissOnMouseLeave && obj.isWaitingDismiss) {
				obj.cancelDismiss()
			}
		})
		this.div.addEventListener('mouseleave', function(event) {
			obj.incEnterCounter(-1)
			if (obj.dismissOnMouseLeave) {
				obj.reserveDismiss(true)
			}
		})
		this.div.addEventListener('pointerdown', function(event) {
			event.stopPropagation()
		})
		document.addEventListener('pointerdown', function(event) {
			obj.dismiss()
		})
	}
	addItem() {
		let item = new PopupMenuItem(this)
		this.div.appendChild(item.div)
		return item
	}
	show(x, y, autoAdjustment=true, hAlign=0, vAlign=0) {
		let style = this.div.style
		style.display = ''
		if (document.documentElement && (document.documentElement.scrollTop || document.documentElement.scrollLeft))
		{
			x += document.documentElement.scrollLeft;
			y += document.documentElement.scrollTop;
		}
		else if (document.body && (document.body.scrollTop || document.body.scrollLeft))
		{
			x += document.body.scrollLeft;
			y += document.body.scrollTop;
		}
		else if (window.pageXOffset || window.pageYOffset)
		{
			x += window.pageXOffset;
			y += window.pageYOffset;
		}
		let rect = this.div.getBoundingClientRect()
		if (autoAdjustment) {
			if (x + rect.width > window.innerWidth) {
				hAlign = 1
			}
			if (y + rect.height > window.innerHeight) {
				vAlign = 1
			}
		}
		style.left = (x - rect.width * hAlign) + 'px'
		style.top = (y - rect.height * vAlign) + 'px'
		style.zIndex = 100
		if (this.parent) {
			if (this.parent.child) {
				this.parent.child.dismissFromParent()
			}
			this.parent.child = this
		}
	}
	get isVisible() {
		return this.div.style.display != ''
	}
	dismiss() {
		let style = this.div.style
		style.display = 'none'
		this.cancelDismiss()
		if (this.child) {
			this.child.dismiss()
			this.child = null
		}
	}
	dismissFromParent() {
		if (this.mouseEnterCounter == 0) {
			let style = this.div.style
			style.display = 'none'
			this.cancelDismiss()
		}
		if (this.child) {
			this.child.dismissFromParent()
			this.child = null
		}
	}
	dismissToRoot() {
		if (this.child) {
			this.child.dismissFromParent()
			this.child = null
		}
		if (this.parent && this.mouseEnterCounter == 0) {
			let style = this.div.style
			style.display = 'none'
			this.cancelDismiss()
			this.parent.dismissToRoot()
		}
	}
	incEnterCounter(c) {
		this.mouseEnterCounter += c
		if (this.parent) {
			this.parent.incEnterCounter(c)
		}
	}
	get isWaitingDismiss() {
		return this.dismissTimeoutID != undefined
	}
	cancelDismiss() {
		if (this.dismissTimeoutID) {
			clearTimeout(this.dismissTimeoutID)
			this.dismissTimeoutID = undefined
		}
	}
	reserveDismiss(dismissOnMouseLeave) {
		let obj = this
		this.dismissTimeoutID = setTimeout(function(){
			obj.dismissToRoot()
		}, 500);
		obj.dismissOnMouseLeave = dismissOnMouseLeave
	}
}

function isUndefined(val, def) {
	return val != undefined ? val : def
}
/*
function removeAllChildNodes(parent) {
	while (parent.firstChild) {
		parent.removeChild(parent.firstChild);
	}
}
*/
function array_clear(a) {
	a.splice(0, a.length)
}
function header_getData(header, data) {
	return isUndefined(header.getter ? header.getter(data) : data[header.id], '')
}
class MultiColumnList {
	constructor(div) {
		this._selectedDataKey = undefined
		this._selectedDataStartKey = undefined
		this._selectedDataKeys = []
		this._headers = []
		this._headerinfos = []
		this._data = []
		this._dataOrder = null
		this._dataIndexMap = new Map()
		this._minWidth = 0
		this._rowPerPage = 10
		this._rowOrderMap = new Map()
		this._deferredRefresh = 0
		this.draggable = false
		this._pointerPressed = false
		this._isDragged = false
		this._canDragStart = false
		this._pointerDownElement = null
		this._divEnterCount = 0
		this._rowEnterCount = 0
		this._rowDropped = false
		this._currentHeaderInfo = null
		this._headerFilterItems = []
		this._filterFunction = null
		this.selectMode = false
	  
		let obj = this
		let tblWrap = document.createElement('div')
		tblWrap.tabIndex = -1
		tblWrap.onkeydown = this.getOnKeyDown()
		div.parentNode.replaceChild(tblWrap, div)
		
		let userTblHead = document.createElement('div');
		tblWrap.appendChild(userTblHead)
		
		let tblHeader = document.createElement('table');
		userTblHead.appendChild(tblHeader)
		
		this.tblHeaderColGroup = document.createElement('colgroup');
		tblHeader.appendChild(this.tblHeaderColGroup)
		
		let th = tblHeader.createTHead()
		this.headerRow = th.insertRow()
		
		let userTbl = document.createElement('div');
		
		userTbl.ondrop = function(ev) {
			this.setAttribute('dragHover', 0)
			--obj._divEnterCount
			if (obj.ondrop && !obj._rowDropped) {
				obj.ondrop(ev, null, false)
			}
			obj._rowDropped = false
		}
		userTbl.ondragover = function(ev) {
			if (obj._divEnterCount == 1 && obj._rowEnterCount == 0) {
				if (obj.ondragover && obj.ondragover(ev, null)) {
					this.setAttribute('dragHover', 1)
				}
			}
		}
		userTbl.ondragenter = function(ev) {
			++obj._divEnterCount
			if (obj.ondragenter) {
				obj.ondragenter(ev, null)
			}
		}
		userTbl.ondragleave = function(ev) {
			--obj._divEnterCount
			if (obj.ondragleave) {
				obj.ondragleave(ev, null)
			}
			this.setAttribute('dragHover', 0)
		}
		
		let tblBody = document.createElement('table');
		userTbl.appendChild(tblBody)
		tblWrap.appendChild(userTbl)
		
		let sl = 0
		userTbl.onscroll = function(event) {
			if (sl != userTbl.scrollLeft) {
				sl = userTbl.scrollLeft;
				userTblHead.scrollTo(sl, 0);
			}
		}
		tblBody.ondblclick = function(e) {
			/*
			let element = document.elementFromPoint(e.clientX, e.clientY)
			while (true) {
				if (!element) {
					return
				}
				if (element instanceof HTMLTableRowElement) {
					break
				}
				element = element.parentElement
			}
			
			let event = new MouseEvent('dblclick')
			element.dispatchEvent(event);
			*/
			if (obj.ondblclick) {
				obj.ondblclick(e)
			}
		}
		tblBody.onpointerdown = function(e) {
			let element = document.elementFromPoint(e.clientX, e.clientY)
			while (true) {
				if (!element) {
					return
				}
				if (element instanceof HTMLTableRowElement) {
					break
				}
				element = element.parentElement
			}
			
			const rowIndex = element.rowIndex
			if (!obj.isValidRowIndex(rowIndex) || obj.rows[rowIndex] != element) {
				return
			}
			const dataKey = obj.getDataKeyByRowIndex(rowIndex)
			obj._pointerDownElement = element
			obj._pointerPressed = true
			obj._isDragged = false
			obj._canDragStart = obj.isSelectedRow(dataKey)
			this.setPointerCapture(e.pointerId)
		}
		tblBody.onmousemove = function(e) {
			if (obj._pointerPressed && !obj._canDragStart) {
				if (!obj._isDragged && obj._pointerDownElement) {
					const rowIndex = obj._pointerDownElement.rowIndex
					const dataKey = obj.getDataKeyByRowIndex(rowIndex)
					obj._selectRow(dataKey, rowIndex, e.shiftKey, e.ctrlKey || obj.selectMode)
				}
				let element = document.elementFromPoint(e.clientX, e.clientY)
				while (true) {
					if (!element) {
						return
					}
					if (element instanceof HTMLTableRowElement) {
						break
					}
					element = element.parentElement
				}
				const rowIndex = element.rowIndex
				if (!obj.isValidRowIndex(rowIndex) || obj.rows[rowIndex] != element) {
					return
				}
				const dataKey = obj.getDataKeyByRowIndex(rowIndex)
				obj._selectRow(dataKey, rowIndex, true, e.ctrlKey)
				obj._isDragged = true
			}
		}
		tblBody.onpointerup = function(e) {
			if (obj._pointerPressed) {
				if (!obj._isDragged && obj._pointerDownElement) {
					let rc = obj._pointerDownElement.getBoundingClientRect()
					if (rc.left <= e.clientX && e.clientX < rc.right && rc.top <= e.clientY && e.clientY < rc.bottom) {
						const rowIndex = obj._pointerDownElement.rowIndex
						const dataKey = obj.getDataKeyByRowIndex(rowIndex)
						if (e.button == 2 && obj.isSelectedRow(dataKey)) {
							obj._selectedDataKey = dataKey
						} else if (!obj.selectMode) {
							obj._selectRow(dataKey, rowIndex, e.shiftKey, e.ctrlKey)
						}
					}
				}
				obj._pointerPressed = false
				obj._isDragged = false
				obj._pointerDownElement = null
				obj._canDragStart = false
				this.setPointerCapture(e.pointerId)
			}
		}
		
		this.tblBodyColGroup = document.createElement('colgroup');
		tblBody.appendChild(this.tblBodyColGroup)
		tblBody.style.minHeight = 1
		
		this.tblWrap = tblWrap
		this.userTblHead = userTblHead
		this.userTbl = userTbl
		this.tblHeader = tblHeader
		this.tblBody = tblBody
		
		let _divFilter = document.createElement('div')
		document.body.appendChild(_divFilter);
		_divFilter.style.position = 'absolute'
		_divFilter.style.display = 'none'
		_divFilter.style.flexDirection = 'column'
		_divFilter.style.alignItems = 'stretch'
		_divFilter.tabIndex = -1
		
		let sortAsc = document.createElement('button');
		sortAsc.style.width = '100%'
		sortAsc.textContent = 'Sort, A->Z'
		let sortDsc = document.createElement('button');
		sortDsc.style.width = '100%'
		sortDsc.textContent = 'Sort, Z->A'
		let selectAll = document.createElement('button');
		selectAll.style.width = '50%'
		selectAll.textContent = 'SelectAll'
		let clearAll = document.createElement('button');
		clearAll.style.width = '50%'
		clearAll.textContent = 'ClearAll'
		let search = document.createElement('input');
		search.style.width = '100%'
		search.style.boxSizing = 'border-box'
		search.type = 'text'
		let _divFilterItems = document.createElement('div');
		_divFilterItems.style.width = 300 + 'px'
		_divFilterItems.style.overflow = 'hidden'
		_divFilterItems.style.display = 'flex'
		_divFilterItems.style.flexDirection = 'column'
		_divFilterItems.style.alignItems = 'stretch'
		let divListPanel = document.createElement('div');
		divListPanel.style.height = 150 + 'px'
		divListPanel.style.overflowY = 'auto'
		divListPanel.appendChild(_divFilterItems)
		let cancel = document.createElement('button');
		cancel.style.width = '50%'
		cancel.textContent = 'Cancel'
		let confirm = document.createElement('button');
		confirm.style.width = '50%'
		confirm.textContent = 'OK'
		
		_divFilter.appendChild(sortAsc)
		_divFilter.appendChild(sortDsc)
		let _divTemp = document.createElement('div');
		_divTemp.style.width = '100%'
		_divTemp.appendChild(selectAll)
		_divTemp.appendChild(clearAll)
		_divFilter.appendChild(_divTemp)
		_divFilter.appendChild(search)
		_divFilter.appendChild(divListPanel)
		_divTemp = document.createElement('div');
		_divTemp.style.width = '100%'
		_divTemp.appendChild(cancel)
		_divTemp.appendChild(confirm)
		_divFilter.appendChild(_divTemp)
		
		this._divFilter = _divFilter
		this._divFilterItems = _divFilterItems
		this._divListPanel = divListPanel
		this._filterSearch = search
		this._sortAsc = sortAsc
		this._sortDsc = sortDsc
		
		_divFilter.onkeydown = function(e) {
			if (e.keyCode == 27) {
				obj.closeHeaderFilterDiv()
			}
		}
		sortAsc.onclick = function() {
			let header = obj._currentHeaderInfo.header
			obj._data.sort(function(a,b) {
				a = header_getData(header, a)
				b = header_getData(header, b)
				return a < b ? -1 : a > b ? 1 : 0
			})
			obj.refreshDataIndexMap()
			obj.refreshList()
			obj.closeHeaderFilterDiv()
			if (obj.onSorted) {
				obj.onSorted(1)
			}
		}
		sortDsc.onclick = function() {
			let header = obj._currentHeaderInfo.header
			obj._data.sort(function(a,b) {
				a = header_getData(header, a)
				b = header_getData(header, b)
				return a < b ? 1 : a > b ? -1 : 0
			})
			obj.refreshDataIndexMap()
			obj.refreshList()
			obj.closeHeaderFilterDiv()
			if (obj.onSorted) {
				obj.onSorted(2)
			}
		}
		selectAll.onclick = function() {
			obj.setAllHeaderFilterItemsFlag(true)
		}
		clearAll.onclick = function() {
			obj.setAllHeaderFilterItemsFlag(false)
		}
		cancel.onclick = function() {
			obj.closeHeaderFilterDiv()
		}
		confirm.onclick = function() {
			let _headerFilterItems = obj._headerFilterItems
			let info = obj._currentHeaderInfo
			let filterMap = info.filterMap
			let checkedAll = true
			for (let i = 0; i < _headerFilterItems.length; ++i) {
				let item = _headerFilterItems[i]
				let checked = item.checkbox.checked
				filterMap.get(item.text).checked = checked
				checkedAll = checkedAll && checked
			}
			info.checkedAll = checkedAll
			info.button.textContent = info.header.name + (checkedAll ? 'ðŸ”½' : 'â¬')
			obj.closeHeaderFilterDiv()
			obj.updateFilter()
		}
		search.oninput = function(e) {
			obj.refreshHeaderFilterItems(search.value.toLowerCase())
		}
		_divFilter.onpointerdown = function(e) {
			e.stopPropagation()
		}
		document.addEventListener('pointerdown', function(e) {
			obj.closeHeaderFilterDiv()
		})
	}
	updateFilter() {
		let dataList = this.dataList
		let newDataOrder = []
		for (let i = 0; i < dataList.length; ++i) {
			let data = dataList[i]
			let dataKey = data.key
			let succeeded = true
			if (this._filterFunction) {
				succeeded = this._filterFunction(data)
			}
			if (succeeded) {
				for (let j = 0; j < this._headerinfos.length; ++j) {
					let info = this._headerinfos[j]
					if (info.checkedAll) {
						continue
					}
					let text = header_getData(info.header, data).toString().toLowerCase()
					let result = info.filterMap.get(text).checked
					if (!result) {
						succeeded = false
						break
					}
				}
			}
			if (succeeded) {
				newDataOrder.push(dataKey)
			}
		}
		if (newDataOrder.length == dataList.length) {
			this.setDataOrder(null)
		} else {
			this.setDataOrder(newDataOrder)
		}
	}
	set filterFunction(func) {
		if (this._filterFunction != func) {
			this._filterFunction = func
			this.updateFilter()
		}
	}
	closeHeaderFilterDiv() {
		this._divFilter.style.display = 'none'
		this._currentHeaderInfo = null
	}
	get mainDivClassName() {
		return this.tblWrap.className
	}
	get headerDivClassName() {
		return this.userTblHead.className
	}
	get bodyDivClassName() {
		return this.userTbl.className
	}
	set mainDivClassName(className) {
		this.tblWrap.className = className
	}
	set headerDivClassName(className) {
		this.userTblHead.className = className
	}
	set bodyDivClassName(className) {
		this.userTbl.className = className
	}
	getOnKeyDown() {
		let obj = this
		return function(e) {
			let dataKey = obj.selectedDataKey
			let rowIndex;			
			//console.log(e.keyCode)
			let startKey = obj._selectedDataStartKey
			let startIdx = startKey != undefined ? obj.getRowIndex(startKey) : 0
			if (e.keyCode == 38) {
				if (dataKey == undefined) {
					rowIndex = obj.rowCount - 1
				} else {
					rowIndex = obj.getRowIndex(dataKey) - 1
				}
			} else if (e.keyCode == 40) {
				++rowIndex
				if (dataKey == undefined) {
					rowIndex = 0
				} else {
					rowIndex = obj.getRowIndex(dataKey) + 1
				}
			} else if (e.keyCode == 36) {
				rowIndex = 0
			} else if (e.keyCode == 35) {
				rowIndex = obj.rowCount - 1
			} else if (e.keyCode == 33) {
				if (dataKey == undefined) {
					rowIndex = 0
				} else {
					rowIndex = obj.getRowIndex(dataKey) - obj._rowPerPage
				}
			} else if (e.keyCode == 34) {
				if (dataKey == undefined) {
					rowIndex = 0
				} else {
					rowIndex = obj.getRowIndex(dataKey)
				}
				rowIndex += obj._rowPerPage
			} else if (e.ctrlKey && e.keyCode == 65) {
				startIdx = 0
				rowIndex = obj.rowCount - 1
				obj.clearSelection()
				for (let i = startIdx; i <= rowIndex; ++i) {
					obj._setRowSelection(obj.getDataKeyByRowIndex(i), i)
				}
				e.preventDefault()
				return
			} else {
				if (obj.onkeydown) {
					obj.onkeydown(e)
				}
				return
			}
			
			e.preventDefault()
			rowIndex = obj.clampRowIndex(rowIndex)
			dataKey = obj.getDataKeyByRowIndex(rowIndex)
			if (e.ctrlKey && e.shiftKey) {
			} else if (e.shiftKey) {
				obj.clearSelection()
				let endIdx = rowIndex
				obj._selectedDataStartKey = obj.getDataKeyByRowIndex(startIdx)
				obj._selectedDataKey = dataKey
				if (startIdx > endIdx) {
					[endIdx, startIdx] = [startIdx, endIdx]
				}
				for (let i = startIdx; i <= endIdx; ++i) {
					obj._setRowSelection(obj.getDataKeyByRowIndex(i), i)
				}
				obj.scrollToRow(endIdx, false)
			} else if (e.ctrlKey) {
			} else {
				obj.setRowSelection(dataKey, false)
			}
		}
	}
	clampRowIndex(idx) {
		let len = this.tblBody.rows.length
		if (idx < 0) {
			return 0
		} else if (len <= idx) {
			if (len == 0) {
				return 0
			}
			return len - 1
		}
		return idx
	}
	get rowCount() {
		return this.tblBody.rows.length
	}
	get length() {
		return this._data.length
	}
	get selectedDataKey() {
		return this._selectedDataKey
	}
	get selectedData() {
		return this.getDataByKey(this._selectedDataKey)
	}
	set selectedDataKey(dataKey) {
		let rowIdx = this.getRowIndex(dataKey)
		if (rowIdx != -1) {
			this.clearSelection()
			this.setRowSelection(dataKey, rowIdx)
		}
	}
	get selectedDataIndex() {
		let val = this._dataIndexMap.get(this._selectedDataKey)
		return val != undefined ? val : -1
	}
	get selectedRowIndex() {
		return this.getRowIndex(this._selectedDataKey)
	}
	setRowSelection(dataKey, focusOption) {
		let rowIdx = this.getRowIndex(dataKey)
		if (rowIdx < 0 || this.tblBody.rows.length <= rowIdx) {
			this._selectedDataKey = undefined
		} else {
			this.clearSelection()
			this._setRowSelection(dataKey, rowIdx)
			this._selectedDataKey = dataKey
			this._selectedDataStartKey = dataKey
			this.scrollToRow(rowIdx, focusOption)
		}
	}
	set selectedDataIndex(dataIdx) {
		this.setRowSelection(dataIdx, true)
	}
	set selectedRowIndex(rowIdx) {
		this.setRowSelection(this.getDataKeyByRowIndex(rowIdx), true)
	}
	scrollToRow(rowIdx, option) {
		if (rowIdx < 0) {
			rowIdx = this.tblBody.rows.length + rowIdx
		}
		this.tblBody.rows[rowIdx].scrollIntoViewIfNeeded(option)
	}
	scrollToRowByDataKey(dataKey, option) {
		let rowIdx = this.getRowIndex(dataKey)
		if (rowIdx != -1) {
			this.scrollToRow(rowIdx, option)
		}
	}
	get rows() {
		return this.tblBody.rows
	}
	setHeader(headers) {
		this._headers = headers
		//removeAllChildNodes(this.tblHeaderColGroup)
		//removeAllChildNodes(this.tblBodyColGroup)
		this.tblHeaderColGroup.replaceChildren()
		this.tblBodyColGroup.replaceChildren()
		
		let width = 0
		let len = headers.length
		for (let i = 0; i < len; ++i) {
			let header = headers[i]
			let w = header.width
			width += w
			let col1 = document.createElement('col')
			this.tblHeaderColGroup.appendChild(col1)
			let col2 = document.createElement('col')
			this.tblBodyColGroup.appendChild(col2)
			
			if (header.autoSize) {
				col1.style.minWidth = w + 'px'
				col2.style.minWidth = w + 'px'
			} else {
				col1.style.width = w + 'px'
				col2.style.width = w + 'px'
			}
		}
		
		let col = document.createElement('col')
		this.tblHeaderColGroup.appendChild(col)
		this._lastHeaderColumn = col
		
		this.tblBody.style.minWidth = width + 'px'
		this.tblHeader.style.minWidth = width + 'px'
		this._minWidth = width + 'px'
		//removeAllChildNodes(this.headerRow)
		this.headerRow.replaceChildren()
		
		this._headerinfos = []
		let obj = this
		for (let i = 0; i < headers.length; ++i) {
			let cell = document.createElement('th');
			this.headerRow.appendChild(cell)
			let header = headers[i]
			if (header.title) {
				cell.setAttribute('title', header.title)
			}
			let info = { idx:i, header:header, checkedAll:true, initFilter:true, sorted:true, filterList:[], filterMap:new Map() }
			this._headerinfos.push(info)
			if (header.filter) {
				let button = document.createElement('button');
				info.button = button
				cell.appendChild(button)
				button.textContent = header.name + 'ðŸ”½'
				button.style = "font-size:14px;font-weight:bold"
				button.onclick = this.getToggleSortFunction(i)
			} else {
				let newText = document.createTextNode(header.name);
				cell.appendChild(newText);
			}
		}
		let cell = document.createElement('th');
		this.headerRow.appendChild(cell)
		
		this.adjustScroll()
		this.refreshList()
	}
	selectHeader(names) {
		let result = []
		for (let i = 0; i < names.length; ++i) {
			const name = names[i]
			for (let j = 0; j < this._headers.length; ++j) {
				const header = this._headers[j]
				if (header.id == name) {
					result.push(header)
					break
				}
			}
		}
		return result
	}
	static addDataToFilter(headerinfo, data) {
		let filterList = headerinfo.filterList
		let filterMap = headerinfo.filterMap
		let text = header_getData(headerinfo.header, data)
		text = isUndefined(text, '').toString().toLowerCase()
		let filterData = filterMap.get(text)
		if (filterData == undefined) {
			filterData = { data:[data], text:text, checked:true }
			filterList.push(filterData)
			filterMap.set(text, filterData)
			headerinfo.sorted = false
		} else {
			filterData.data.push(data)
		}
	}
	addDataToFilters(data) {
		for (let j = 0; j < this._headerinfos.length; ++j) {
			MultiColumnList.addDataToFilter(this._headerinfos[j], data)
		}
	}
	getToggleSortFunction(index) {
		let obj = this
		let info = this._headerinfos[index]
		return function(e) {
			let filterList = info.filterList
			let filterMap = info.filterMap
			let header = info.header
			if (info.initFilter) {
				array_clear(filterList)
				filterMap.clear()
				let dataList = obj._data
				for (let i = 0; i < dataList.length; ++i) {
					MultiColumnList.addDataToFilter(info, dataList[i])
				}
				info.initFilter = false
				info.sorted = false
			}
			
			if (!info.sorted) {
				if (header.numeric) {
					filterList.sort(function(a, b) { return a.text - b.text })
				} else {
					filterList.sort()
				}
				info.sorted = true
			}
			
			let _divFilterItems = obj._divFilterItems
			//removeAllChildNodes(_divFilterItems)
			_divFilterItems.replaceChildren()
			obj._headerFilterItems = []
			for (let i = 0; i < filterList.length; ++i) {
				let text = filterList[i].text
				let label = document.createElement('label')
				let checkbox = document.createElement('input')
				checkbox.type = 'checkbox'
				checkbox.style.cursor = 'pointer'
				checkbox.checked = filterMap.get(text).checked
				label.appendChild(checkbox)
				label.appendChild(document.createTextNode(text.length ? text : '(empty)'))
				label.style.textOverflow = 'ellipsis'
				label.style.whiteSpace = 'nowrap'
				label.style.overflow = 'hidden'
				label.style.display = 'inline-block'
				label.style.width = '100%'
				label.style.userSelect = 'none'
				label.style.cursor = 'pointer'
				label.title = text
				_divFilterItems.appendChild(label)
				let found = true
				if (obj._filterFunction) {
					let data = filterList[i].data
					found = false
					for (let j = 0; j < data.length; ++j) {
						if (obj._filterFunction(data[j])) {
							found = true
							break
						}
					}
				}
				if (!found) {
					label.style.display = 'none'
				}
				obj._headerFilterItems.push({ text:text, label:label, checkbox:checkbox, enabled:found, display:found })
			}

			let style = obj._divFilter.style
			let viewportOffset = this.getBoundingClientRect();
			let offsetX = viewportOffset.left, offsetY = viewportOffset.bottom
			if (document.documentElement && (document.documentElement.scrollTop || document.documentElement.scrollLeft))
			{
				offsetX += document.documentElement.scrollLeft;
				offsetY += document.documentElement.scrollTop;
			}
			else if (document.body && (document.body.scrollTop || document.body.scrollLeft))
			{
				offsetX += document.body.scrollLeft;
				offsetY += document.body.scrollTop;
			}
			else if (window.pageXOffset || window.pageYOffset)
			{
				offsetX += window.pageXOffset;
				offsetY += window.pageYOffset;
			}
			
			style.left = offsetX + 'px'
			style.top = offsetY + 'px'
			style.background = 'white'
			style.display = 'flex'
			style.zIndex = 100

			let rc = obj._divFilter.getBoundingClientRect()
			if (rc.right > window.innerWidth) {
				style.left = (window.innerWidth - rc.width - 20) + 'px'
			}
			obj._sortAsc.style.display = header.sort ? '' : 'none'
			obj._sortDsc.style.display = header.sort ? '' : 'none'
			obj._divListPanel.scrollTo(0, 0)
			
			obj._divFilter.focus()
			obj._filterSearch.value = ''
			obj._currentHeaderInfo = info
		}
	}
	setAllHeaderFilterItemsFlag(val) {
		let _headerFilterItems = this._headerFilterItems
		for (let i = 0; i < _headerFilterItems.length; ++i) {
			let item = _headerFilterItems[i]
			if (item.display) {
				item.checkbox.checked = val
			}
		}
	}
	refreshHeaderFilterItems(text) {
		let _headerFilterItems = this._headerFilterItems
		for (let i = 0; i < _headerFilterItems.length; ++i) {
			let item = _headerFilterItems[i]
			if (!item.enabled) {
				continue
			}
			let display = text.length == 0 || item.text.indexOf(text) != -1
			item.display = display
			item.label.style.display = display ? '' : 'none'
		}
	}
	resetFilterCache() {
		for (let j = 0; j < this._headerinfos.length; ++j) {
			let info = this._headerinfos[j]
			info.checkedAll = true
			info.initFilter = true
		}
	}
	setData(data) {
		this._data = data
		this.refreshDataIndexMap()
		this.resetFilterCache()
		this.rebuildList()
	}
	_getCellHoverFunction(text) {
		return function (e) {
			if (this.offsetWidth < this.scrollWidth) {
				this.setAttribute('title', text)
			}
		}
	}
	adjustScroll() {
		let width = this._minWidth
		//console.log(this.userTbl.scrollHeight, this.userTbl.clientHeight)
		if ((this.userTbl.scrollHeight == 0 && this.userTbl.clientHeight == 0) || (this.userTbl.scrollHeight > this.userTbl.clientHeight)) {
			this._lastHeaderColumn.style.width = 17 + 'px'
			width += 17
		} else {
			this._lastHeaderColumn.style.width = 0 + 'px'
		}
		this.tblHeader.style.minWidth = width + 'px'
	}
	getOnDblClick() {
		let obj = this
		return function(e) {
			if (obj.ondblclick) {
				obj.ondblclick(e)
			}
		}
	}
	getRowIndex(dataKey) {
		let idx = this._rowOrderMap.get(dataKey)
		return idx != undefined ? idx : -1
	}
	getDataKeyByRowIndex(rowIdx) {
		if (rowIdx < 0) {
			return undefined
		}
		if (this._dataOrder) {
			return rowIdx < this._dataOrder.length ? this._dataOrder[rowIdx] : undefined
		}
		return rowIdx < this._data.length ? this._data[rowIdx].key : undefined
	}
	getDataIndexByRowIndex(rowIdx) {
		let key = this.getDataKeyByRowIndex(rowIdx)
		return key != undefined ? this._dataIndexMap.get(key) : -1
	}
	getDataIndexByKey(dataKey) {
		let idx = this._dataIndexMap.get(dataKey)
		return idx != undefined ? idx : -1
	}
	_selectRow(dataKey, rowIndex, shiftKey, ctrlKey) {
		if (ctrlKey && shiftKey) {
			if (this._selectedDataStartKey == undefined) {
				this._setRowSelection(dataKey, rowIndex)
				this._selectedDataKey = dataKey
				this._selectedDataStartKey = dataKey
			} else {
				let startIdx = this._selectedDataStartKey
				if (this.isSelectedRow(startIdx)) {
					startIdx = this.getRowIndex(startIdx)
					let endIdx = rowIndex
					if (startIdx > endIdx) {
						[endIdx, startIdx] = [startIdx, endIdx]
					}
					for (let i = startIdx; i <= endIdx; ++i) {
						this._setRowSelection(this.getDataKeyByRowIndex(i), i)
					}
					this._selectedDataKey = dataKey
				} else {
					this._selectedDataStartKey = dataKey
				}
			}
		} else if (shiftKey) {
			let startKey = this._selectedDataStartKey
			this.clearSelection()
			if (startKey == undefined) {
				this._setRowSelection(dataKey, rowIndex)
				this._selectedDataKey = dataKey
				this._selectedDataStartKey = dataKey
			} else {
				let startIdx = this.getRowIndex(startKey)
				let endIdx = rowIndex
				if (startIdx > endIdx) {
					[endIdx, startIdx] = [startIdx, endIdx]
				}
				for (let i = startIdx; i <= endIdx; ++i) {
					this._setRowSelection(this.getDataKeyByRowIndex(i), i)
				}
				this._selectedDataStartKey = startKey
				this._selectedDataKey = dataKey
			}
		} else if (ctrlKey) {
			let idx = this._selectedDataKeys.indexOf(dataKey)
			if (idx == -1) {
				this._setRowSelection(dataKey, rowIndex)
				this._selectedDataKey = dataKey
			} else {
				this._selectedDataKeys.splice(idx, 1)
				this.clearRowSelectionStyle(rowIndex)
			}
			this._selectedDataStartKey = dataKey
		} else {
			this.clearSelection()
			this._setRowSelection(dataKey, rowIndex)
			this._selectedDataKey = dataKey
			this._selectedDataStartKey = dataKey
		}
	}
	get selectedDataKeys() {
		return this._selectedDataKeys
	}
	get headers() {
		return this._headers
	}
	isSelectedRow(dataKey) {
		return this._selectedDataKeys.indexOf(dataKey) != -1
	}
	_setRowSelection(dataKey, rowIdx) {
		this.setRowSelectionStyle(rowIdx)
		if (this._selectedDataKeys.indexOf(dataKey) == -1) {
			this._selectedDataKeys.push(dataKey)
		}
	}
	isValidRowIndex(rowIdx) {
		return 0 <= rowIdx && rowIdx < this.rowCount
	}
	setDataRowSelection(dataKey, select) {
		let rowIdx = this.getRowIndex(dataKey)
		if (rowIdx == -1) {
			return
		}
		let idx = this._selectedDataKeys.indexOf(dataKey)
		if (select && idx == -1) {
			this.setRowSelectionStyle(rowIdx)
			this._selectedDataKeys.push(dataKey)
		} else if (idx != -1) {
			this.clearRowSelectionStyle(rowIdx)
			this._selectedDataKeys.splice(idx, 1)
		}
	}
	setRowSelectionStyle(rowIdx) {
		this.tblBody.rows[rowIdx].setAttribute('selected', true)
	}
	clearRowSelectionStyle(rowIdx) {
		this.tblBody.rows[rowIdx].setAttribute('selected', false)
	}
	selectAll() {
		if (this._data.length <= 0) {
			return
		}
		this._selectedDataKeys = []
		for (let i = 0; i < this._data.length; ++i) {
			this._selectedDataKeys.push(this._data[i].key)
			this.setRowSelectionStyle(i)
		}

		this._selectedDataKey = this._data[0].key
		this._selectedDataStartKey = this._data[0].key
	}
	clearSelection() {
		for (let i = 0; i < this._selectedDataKeys.length; ++i) {
			this.clearRowSelectionStyle(this.getRowIndex(this._selectedDataKeys[i]))
		}
		this._selectedDataKeys = []
		this._selectedDataKey = undefined
		this._selectedDataStartKey = undefined
	}
	refreshSelection() {
		for (let i = 0; i < this._selectedDataKeys.length; ++i) {
			this.setRowSelectionStyle(this.getRowIndex(this._selectedDataKeys[i]))
		}
	}
	get dataList() {
		return this._data
	}
	getData(dataIndex) {
		return this._data[dataIndex]
	}
	getDataByKey(dataKey) {
		if (Array.isArray(dataKey)) {
			let items = []
			for (let i = 0; i < dataKey.length; ++i) {
				let idx = this.getDataIndexByKey(dataKey[i])
				if (idx != -1) {
					items.push(this._data[idx])
				}
			}
			return items
		} else {
			let idx = this.getDataIndexByKey(dataKey)
			return idx != -1 ? this._data[idx] : null
		}
	}
	get dataOrder() {
		return this._dataOrder
	}
	rebuildList() {
		this._dataOrder = null
		this.refreshList()
	}
	copyDataOrder() {
		if (this._dataOrder) {
			return this._dataOrder.slice()
		}
		let dataOrder = []
		let dataList = this._data
		for (let i = 0; i < dataList.length; ++i) {
			dataOrder.push(dataList[i].key)
		}
		return dataOrder
	}
	setDataOrder(newDataOrder) {
		if (this._deferredRefresh) {
			this._dataOrder = newDataOrder
			return 
		}
		if (this._dataOrder == newDataOrder || newDataOrder == null) {
			this._dataOrder = newDataOrder
			this.refreshList()
			return
		}
		if (this._dataOrder == null) {
			this._dataOrder = newDataOrder
			this.refreshList()
			return
		}
		let selectedDataKeys = this._selectedDataKeys
		this._selectedDataKeys = []
		
		this._rowOrderMap.clear()
		let oldDataOrder = this._dataOrder
		this._dataOrder = newDataOrder
		let len = Math.min(newDataOrder.length, oldDataOrder.length)
		for (let i = 0; i < len; ++i) {
			let key = newDataOrder[i]
			this._rowOrderMap.set(key, i)
			if (oldDataOrder[i] == key) {
				this.updateRow(key, i)
				continue
			}
			this.tblBody.deleteRow(i)
			let dataIdx = this._dataIndexMap.get(key)
			if (dataIdx != undefined) {
				this._insertRow(key, dataIdx, i)
			}
		}
		
		for (let i = this.rowCount - 1; i >= len; --i) {
			this.tblBody.deleteRow(i)
		}
		for (let i = len; i < newDataOrder.length; ++i) {
			let key = newDataOrder[i]
			this._rowOrderMap.set(key, i)
			let dataIdx = this._dataIndexMap.get(key)
			if (dataIdx != undefined) {
				this._insertRow(key, dataIdx, i)
			}
		}
		this.adjustScroll()
		for (let i = 0; i < selectedDataKeys.length; ++i) {
			let key = selectedDataKeys[i]
			let idx = this.getRowIndex(key)
			if (idx != -1) {
				this._setRowSelection(key, idx)
			}
		}
	}
	refreshDataIndexMap() {
		const _dataIndexMap = this._dataIndexMap
		const dataList = this._data
		
		_dataIndexMap.clear()
		for (let i = 0; i < dataList.length; ++i) {
			_dataIndexMap.set(dataList[i].key, i)
			
		}
	}
	refreshRowIndexMap() {
		const _rowOrderMap = this._rowOrderMap
		_rowOrderMap.clear()
		if (this._dataOrder) {
			const _dataOrder = this._dataOrder
			for (let i = 0; i < _dataOrder.length; ++i) {
				_rowOrderMap.set(_dataOrder[i], i)
			}
		} else {
			const _data = this._data
			for (let i = 0; i < _data.length; ++i) {
				_rowOrderMap.set(_data[i].key, i)
			}
		}
	}
	refreshList() {
		if (this._deferredRefresh) {
			return
		}
		let selectedDataKeys = this._selectedDataKeys
		this._selectedDataKeys = []
		
		let rows = this.rows
		for (let i = rows.length - 1; i >= 0; --i) {
			this.tblBody.deleteRow(i)
		}
		this._rowOrderMap.clear()
		
		if (this._dataOrder) {
			let dataOrder = this._dataOrder
			let newDataOrder = []
			let rowIdx = 0
			for (let i = 0; i < dataOrder.length; ++i) {
				let key = dataOrder[i]
				let dataIdx = this._dataIndexMap.get(key)
				if (dataIdx != undefined) {
					this._rowOrderMap.set(key, rowIdx)
					this._insertRow(key, dataIdx, rowIdx)
					newDataOrder.push(key)
					++rowIdx
				}
			}
			this._dataOrder = newDataOrder
		} else {
			let data = this._data
			for (let i = 0; i < data.length; ++i) {
				let key = data[i].key
				this._rowOrderMap.set(key, i)
				this._insertRow(key, i, i)
			}
		}
		this.adjustScroll()
		for (let i = 0; i < selectedDataKeys.length; ++i) {
			let key = selectedDataKeys[i]
			let idx = this.getRowIndex(key)
			if (idx != -1) {
				this._setRowSelection(key, idx)
			}
		}
	}
	getDataIndexesByKeys(keys) {
		let dataIndexes = []
		for (let i = 0; i < keys.length; ++i) {
			dataIndexes.push(this.getDataIndexByKey(keys[i]))
		}
		dataIndexes.sort(function(a,b) { return a - b; })
		return dataIndexes
	}
	getRowIndexesByKeys(keys) {
		let rowIndexes = []
		for (let i = 0; i < keys.length; ++i) {
			rowIndexes.push(this.getRowIndex(keys[i]))
		}
		rowIndexes.sort(function(a,b) { return a - b; })
		return rowIndexes
	}
	beginUpdate() {
		++this._deferredRefresh
	}
	endUpdate() {
		if (--this._deferredRefresh <= 0) {
			this._deferredRefresh = 0
			this.refreshList()
		}
	}
	deleteDataByKeys(keys) {
		let dataIndexes = this.getDataIndexesByKeys(keys)
		let rowIndexes = this.getRowIndexesByKeys(keys)
		let data = this._data
		let deletedDataList = []
		for (let i = dataIndexes.length - 1; i >= 0; --i) {
			let idx = dataIndexes[i]
			deletedDataList.push(data[idx])
			data.splice(idx, 1)
		}
		this.refreshDataIndexMap()
		if (this.dataOrder) {
			let dataOrder = this.dataOrder
			for (let i = rowIndexes.length - 1; i >= 0; --i) {
				dataOrder.splice(rowIndexes[i], 1)
			}
		}
		this.refreshRowIndexMap()
		this.refreshList()
		this.resetFilterCache()
		deletedDataList.reverse()
		return deletedDataList
	}
	deleteDataByKey(key) {
		let dataIndex = this.getDataIndexByKey(key)
		let rowIdx = this.getRowIndex(key)
		let dataList = this.dataList
		let deletedData = dataList[dataIndex]
		dataList.splice(dataIndex, 1)
		this.refreshDataIndexMap()
		if (this.dataOrder && rowIdx != -1) {
			this.dataOrder.splice(rowIdx, 1)
		}
		this.refreshRowIndexMap()
		this.resetFilterCache()
		this.refreshList()
		return deletedData
	}
	clampDataIndex(idx) {
		let len = this.length
		if (idx < 0) {
			return 0
		} else if (len <= idx) {
			if (len == 0) {
				return 0
			}
			return len - 1
		}
		return idx
	}
	insertDataList(dataList, atDataKey=null, front=false) {
		let _data = this._data
		if (atDataKey == null) {
			if (front) {
				for (let i = 0; i < dataList.length; ++i) {
					const data = dataList[i]
					this.addDataToFilters(data)
					_data.splice(i, 0, data)
					if (this._dataOrder) {
						this._dataOrder.splice(i, 0, data.key)
					}
				}
			} else {
				for (let i = 0; i < dataList.length; ++i) {
					const data = dataList[i]
					this.addDataToFilters(data)
					_data.push(data)
					if (this._dataOrder) {
						this._dataOrder.push(data.key)
					}
				}
			}
		} else {
			let idx = this.getDataIndexByKey(atDataKey)
			if (idx == -1) {
				for (let i = 0; i < dataList.length; ++i) {
					const data = dataList[i]
					this.addDataToFilters(data)
					_data.push(data)
					if (this._dataOrder) {
						this._dataOrder.push(data.key)
					}
				}
			} else {
				let rowIdx = this.getRowIndex(atDataKey)
				if (!front) {
					++idx
					if (rowIdx != -1) {
						++rowIdx
					}
				}
				for (let i = 0; i < dataList.length; ++i) {
					const data = dataList[i]
					this.addDataToFilters(data)
					_data.splice(idx + i, 0, data)
					if (this._dataOrder && rowIdx != -1) {
						this._dataOrder.splice(rowIdx + i, 0, data.key)
					}
				}
			}
		}
		this.refreshDataIndexMap()
		this.refreshRowIndexMap()
		this.refreshList()
	}
	insertData(data, atDataKey=null, front=false) {
		this.addDataToFilters(data)
		if (atDataKey == null) {
			if (front) {
				this._data.splice(0, 0, data)
				if (this._dataOrder) {
					this._dataOrder.splice(0, 0, data.key)
				}
				this.refreshDataIndexMap()
				this.refreshRowIndexMap()
			} else {
				this._dataIndexMap.set(data.key, this._data.length)
				this._data.push(data)
				if (this._dataOrder) {
					this._dataOrder.push(data.key)
				}
			}
		} else {
			let idx = this.getDataIndexByKey(atDataKey)
			if (idx == -1) {
				this._dataIndexMap.set(data.key, this._data.length)
				this._data.push(data)
				if (this._dataOrder) {
					this._dataOrder.push(data.key)
				}
			} else {
				let rowIdx = this.getRowIndex(atDataKey)
				if (!front) {
					++idx
					if (rowIdx != -1) {
						++rowIdx
					}
				}
				this._data.splice(idx, 0, data)
				if (this._dataOrder && rowIdx != -1) {
					this._dataOrder.splice(rowIdx, 0, data.key)
				}
				this.refreshDataIndexMap()
				this.refreshRowIndexMap()
			}
		}
		this.refreshList()
	}
	moveSelectionToFront() {
		if (this.selectedDataKeys.length == 0) {
			return
		}
		
		let rowIndexes = this.getRowIndexesByKeys(this.selectedDataKeys)
		let reselectRowIdx = -1;
		for (let i = 0; i < rowIndexes.length; ++i) {
			const idx = rowIndexes[i] + 1
			if (idx < this.rowCount && rowIndexes.indexOf(idx) == -1) {
				reselectRowIdx = idx
				break
			}
		}
		if (reselectRowIdx == -1) {
			reselectRowIdx = rowIndexes[0] - 1
		}
		let reselectDataKey = this.getDataKeyByRowIndex(reselectRowIdx)
		let dataList = this.deleteDataByKeys(this.selectedDataKeys)
		let dataKey = this.getDataKeyByRowIndex(0)
		this.insertDataList(dataList, dataKey, true)
		this.selectedDataKey = reselectDataKey
	}
	moveSelectionToBack() {
		if (this.selectedDataKeys.length == 0) {
			return
		}
		
		let rowIndexes = this.getRowIndexesByKeys(this.selectedDataKeys)
		let reselectRowIdx = -1;
		for (let i = 0; i < rowIndexes.length; ++i) {
			const idx = rowIndexes[i] + 1
			if (idx < this.rowCount && rowIndexes.indexOf(idx) == -1) {
				reselectRowIdx = idx
				break
			}
		}
		if (reselectRowIdx == -1) {
			reselectRowIdx = rowIndexes[0] - 1
		}
		let reselectDataKey = this.getDataKeyByRowIndex(reselectRowIdx)
		let dataList = this.deleteDataByKeys(this.selectedDataKeys)
		let dataKey = this.getDataKeyByRowIndex(this.rowCount - 1)
		this.insertDataList(dataList, dataKey, false)
		this.selectedDataKey = reselectDataKey
	}
	moveSelectedItemUp() {
		let selectedDataKey = this._selectedDataKey
		if (selectedDataKey == undefined) {
			return
		}
		let rowIndex = this.getRowIndex(selectedDataKey) - 1
		if (0 <= rowIndex) {
			let dataKey = this.getDataKeyByRowIndex(rowIndex)
			let data = this.deleteDataByKey(selectedDataKey)
			this.insertData(data, dataKey, true)
			this.selectedDataKey = data.key
		}
	}
	moveSelectedItemDown() {
		let selectedDataKey = this._selectedDataKey
		if (selectedDataKey == undefined) {
			return
		}
		let rowIndex = this.getRowIndex(selectedDataKey) + 1
		if (rowIndex < this.rowCount) {
			let dataKey = this.getDataKeyByRowIndex(rowIndex)
			let data = this.deleteDataByKey(selectedDataKey)
			this.insertData(data, dataKey, false)
			this.selectedDataKey = data.key
		}
	}
	deleteSelection() {
		if (this.selectedDataKeys.length == 0) {
			return []
		}
		
		const selectedKeys = this.selectedDataKeys.slice()
		let rowIndexes = this.getRowIndexesByKeys(selectedKeys)
		let reselectRowIdx = -1;
		for (let i = 0; i < rowIndexes.length; ++i) {
			const idx = rowIndexes[i] + 1
			if (idx < this.rowCount && rowIndexes.indexOf(idx) == -1) {
				reselectRowIdx = idx
				break
			}
		}
		if (reselectRowIdx == -1) {
			reselectRowIdx = rowIndexes[0] - 1
		}
		let reselectDataKey = this.getDataKeyByRowIndex(reselectRowIdx)
		this.selectedDataKey = reselectDataKey
		let result = this.deleteDataByKeys(selectedKeys)
		this.refreshList()
		return result
	}
	getOnClick(dataKey) {
		let obj = this
		return function(e) {
			obj.tblWrap.focus()
			obj._selectRow(dataKey, this.rowIndex, e.shiftKey, e.ctrlKey || obj.selectMode)
		}
	}
	_insertRow(dataKey, dataIdx, rowIdx) {
		let obj = this
		let data = this._data[dataIdx]
		let row = this.tblBody.insertRow(rowIdx)			
		row.style.fontSize = 14
		row.onclick = this.getOnClick(dataKey)
		row.ondblclick = this.getOnDblClick()
		row.draggable = this.draggable
		row.ondragstart = function(ev) {
			if (!obj._canDragStart || !obj.isSelectedRow(dataKey)) {
				ev.preventDefault()
				return
			}
			if (obj.ondragstart) {
				obj.ondragstart(ev, dataKey)
			}
		}
		row.ondrop = function(ev) {
			--obj._rowEnterCount
			this.setAttribute('dragHover', 0)
			if (obj.ondrop) {
				obj.ondrop(ev, dataKey, ev.offsetY < this.offsetHeight / 2)
			}
			obj._rowDropped = true
		}
		row.ondragover = function(ev) {
			if (obj.ondragover) {
				const style = obj.ondragover(ev, dataKey)
				if (style) {
					if (style == 2) {
						this.setAttribute('dragHover', 3)
					} else if (ev.offsetY < this.offsetHeight / 2) {
						this.setAttribute('dragHover', 1)
					} else {
						this.setAttribute('dragHover', 2)
					}
				}
			}
		}
		row.ondragenter = function(ev) {
			++obj._rowEnterCount
			if (obj.ondragenter) {
				obj.ondragenter(ev, dataKey)
			}
		}
		row.ondragleave = function(ev) {
			--obj._rowEnterCount
			if (obj.ondragleave) {
				obj.ondragleave(ev, dataKey)
			}
			this.setAttribute('dragHover', 0)
		}
		row.addEventListener('contextmenu', function(event) {
			if (obj.oncontextmenu) {
				if (!obj.isSelectedRow(dataKey)) {
					obj._selectRow(dataKey, rowIdx, event.shiftKey, event.ctrlKey)
				}
				obj.oncontextmenu(event, dataKey)
			}
		})
		for (let j = 0; j < this._headers.length; ++j) {
			let cell = row.insertCell(j)
			let header = this._headers[j]
			let text = header_getData(header, data)
			let textElement = document.createTextNode(text);
			cell.appendChild(textElement);
			cell.onmouseenter = this._getCellHoverFunction(text)
		}
	}
	updateDataRow(dataKey) {
		let rowIdx = this.getRowIndex(dataKey)
		if (rowIdx != -1) {
			this.updateRow(dataKey, rowIdx)
		}
	}
	updateRow(dataKey, rowIdx) {
		let row = this.tblBody.rows[rowIdx]
		let cells = row.cells
		let dataIdx = this.getDataIndexByKey(dataKey)
		let data = this.getData(dataIdx)
		for (let j = 0; j < this._headers.length; ++j) {
			let cell = cells[j]
			let header = this._headers[j]
			//removeAllChildNodes(cell)
			cell.replaceChildren()
			let text = header_getData(header, data)
			let textElement = document.createTextNode(text);
			cell.appendChild(textElement);
			cell.onmouseenter = this._getCellHoverFunction(text)
		}
		if (this.isSelectedRow(dataKey)) {
			this.setRowSelectionStyle(rowIdx)
		} else {
			this.clearRowSelectionStyle(rowIdx)
		}
	}
	updateList() {
		let rows = this.tblBody.rows
		for (let i = 0; i < rows.length; ++i) {
			this.updateRow(this.getDataKeyByRowIndex(i), i)
		}
	}
	focus() {
		this.tblWrap.focus()
	}
}
		</script>
		<script type="text/javascript" charset="utf-8">
let popupWnd = null
let playerLoaded = false
let videoClipMap = new Map()
const videoWidth = 800
const videoHeight = 450

const PLAYMODE_NORMAL = 0
const PLAYMODE_REPEAT_TRACK = 1
const PLAYMODE_REPEAT_ONE = 2
let modePlayList = PLAYMODE_REPEAT_TRACK
let currentViewContext = null
let playContextMap = new Map()
let playContextStack = []
let viewContextStack = []
let currentVideoClip = null
let individualVolumeMap = new Map()
let dataChanged = false
let totalListContextMenu = null
let playListContextMenu = null
let playListItemsContextMenu = null
let spreadsheetsFormList = []
let isLoading = false;

function createSpan(element, style='') {
	let span = document.createElement('span')
	span.replaceChildren(element)
	span.style = style
	return span
}
let isMobile = {
	Android: function() {
		return navigator.userAgent.match(/Android/i);
	},
	BlackBerry: function() {
		return navigator.userAgent.match(/BlackBerry/i);
	},
	iOS: function() {
		return navigator.userAgent.match(/iPhone|iPad|iPod/i);
	},
	Opera: function() {
		return navigator.userAgent.match(/Opera Mini/i);
	},
	Windows: function() {
		return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
	},
	any: function() {
		return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
	}
};
function settings_AddURL(value)
{
	let div = document.createElement('div')
	div.style.display = 'flex'
	let edit = document.createElement('input');
	edit.type = 'text'
	edit.value = value
	edit.style.flex = '1'
	let openSheet = document.createElement('button');
	openSheet.style.flex = 'none'
	let deleteSheet = document.createElement('button');
	deleteSheet.style.flex = 'none'
	div.appendChild(edit)
	div.appendChild(openSheet)
	div.appendChild(deleteSheet)
	divClipSpreadSheetURL.appendChild(div);
	spreadsheetsFormList.push(edit);
	openSheet.textContent = 'OpenSheet'
	openSheet.onclick = function() {
		const url = 'https://docs.google.com/spreadsheets/d/' + edit.value;
		window.open(url, '_blank')
	}
	deleteSheet.textContent = 'Delete'
	deleteSheet.onclick = function() {
		divClipSpreadSheetURL.removeChild(div)
		const idx = spreadsheetsFormList.indexOf(edit)
		if (idx >= 0) {
			spreadsheetsFormList.splice(idx, 1)
		}
	}
}

function readData_Finalize()
{
	let videoClipIDMap = new Map()
	for (let i = 0; i < videoClipList.length; ++i) {
		let value = videoClipList[i]
		//console.log(value)
		makeSearchText(value)
		value.type = 1
		value.ordinal = i + 1
		const Counter = isUndefined(videoClipIDMap.get(value.ID), 1)
		value.key = value.ID + '_' + Counter;
		videoClipIDMap.set(value.ID, Counter + 1)
		value.refCount = 0
		videoClipMap.set(value.key, value)
	}

	videoClipTable.setData(videoClipList)
			
	let playListItems = []
	if (playListData != undefined && playListData.length > 0) {
		showTotallist.checked = false
		showPlaylist.checked = false
		showPlaylistItems.checked = true
		let playListMap = new Map()
		for (let i = 0; i < playListData.length; ++i) {
			let playList = playList_load(playListData[i])
			playListItems.push(playList)
			playListMap.set(playList.key, playList)
		}
		for (let i = 0; i < playListData.length; ++i) {
			const playList = playListItems[i]
			const items = playListData[i].items
			for (let j = 0; j < items.length; ++j) {
				const item = items[j]
				const key = item.key
				let data = playListMap.get(key)
				if (data == undefined) {
					data = videoClipMap.get(key)
				}
				if (data != undefined) {
					playList_newItem(playList, data, item.shufflePriority)
					continue
				}
			}
		}
	} else {
		if (playingList != undefined) {
			showTotallist.checked = false
			showPlaylist.checked = false
			showPlaylistItems.checked = true
			let playList = playList_new()
			playList.trackName = 'ã‚ãŸã‚ã‡ Night Fever'
			playList.originalArtist = 'Various Artist'
			playList.coveredBy = 'Various Artist'
			playList.category = 'ã†ãŸæž ï¼ã‚ãŸã‚ã‡ Night Feverã¨ã‹ðŸ'
			playList.shuffle = false
			makeSearchText(playList)
			for (let i = 0; i < playingList.length; ++i) {
					let data = videoClipMap.get(playingList[i])
					if (data != undefined) {
						playList_newItem(playList, data, 0)
				}
			}
			
			playListItems.push(playList)
		} else {
			const defaultCategory = 'ã†ãŸæž ï¼ã‚ãŸã‚ã‡ Night Feverã¨ã‹ðŸ'
			showTotallist.checked = false
			showPlaylist.checked = false
			showPlaylistItems.checked = true
			let playList = playList_new()
			playList.trackName = 'ã‚ãŸã‚ã‡ Night Fever'
			playList.originalArtist = 'Various Artist'
			playList.coveredBy = 'è§’å·»ã‚ãŸã‚'
			playList.category = defaultCategory
			playList.shuffle = false
			makeSearchText(playList)

			const headers = videoClipTable.selectHeader(['category'])
			const categoryGroupMap = dataList_groupBy(videoClipList, headers)
			
			for (let clipItem of categoryGroupMap.get(defaultCategory)) {
				playList_newItem(playList, clipItem, 0)
			}
			playListItems.push(playList)
		}
	}
	if (playListItems.length) {
		playList_open(playListItems[0])
	}
	playListTable.setData(playListItems)
	videoClipTable.updateList()
	refreshControlPanel()
	updateDivVisible()
	isLoading = false
}
function readData_LoadSheet(URL, dataTable, sheetIdx)
{
	if (dataTable) {
		var jsonData = dataTable.toJSON();
		jsonData = JSON.parse(jsonData);
		let idxMap = new Map()
		let header = jsonData.rows[0].c
		for (let i = 0; i < header.length; ++i) {
			let label = header[i]
			if (label == null) {
				continue
			}
			label = label.v
			if (label == null || label.length == 0) {
				continue
			}
			label = label.toUpperCase()
			idxMap[label] = i
		}

		let dateIdx = idxMap['DATE']
		let trackNameIdx = idxMap['TRACKNAME']
		let originalArtistIdx = idxMap['ORIGINALARTIST']
		let coveredByIdx = idxMap['COVEREDBY']
		let categoryIdx = idxMap['CATEGORY']
		let startIdx = idxMap['START']
		let endIdx = idxMap['END']
		let idIdx = idxMap['ID']
		
		function getVal(c, idx)
		{
			let m = c[idx]
			return m != null ? m.v : ''
		}
		for(var i=1; i < jsonData.rows.length; i++)
		{
			let c = jsonData.rows[i].c
			let row = { category:getVal(c, categoryIdx), ID:getVal(c, idIdx), start:getVal(c, startIdx), end:getVal(c, endIdx), date:getVal(c, dateIdx), trackName:getVal(c, trackNameIdx), coveredBy:getVal(c, coveredByIdx), originalArtist:getVal(c, originalArtistIdx) }
			videoClipList.push(row)
		}
	} else {
		alert('"' + URL + '" is wrong');
	}
	if (++sheetIdx == settingsData.clipSpreadSheetURL.length) {
		readData_Finalize()
	} else {
		const URL = SheetHeader + settingsData.clipSpreadSheetURL[sheetIdx]
		var query = new google.visualization.Query(URL);
		query.send(function(response) { readData_LoadSheet(URL, response.getDataTable(), sheetIdx) });
	}
}
function readData()
{
	if (isLoading) {
		return
	}
	isLoading = true;
	let playListDataText = localStorage.getItem('watamePlayer_PlayList')
	let individualVolumeDataText = localStorage.getItem('watamePlayer_Volumes')
	if (playListDataText) {
		playListData = JSON.parse(playListDataText)
	}
	if (individualVolumeDataText) {
		individualVolumeData = JSON.parse(individualVolumeDataText)
	}
	let settingsDataText = localStorage.getItem('watamePlayer_settings')
	if (settingsDataText) {
		settingsData = JSON.parse(settingsDataText)
		if (settingsData == null) {
			settingsData = {}
		}
		if (settingsData.clipSpreadSheetURL == undefined) {
			settingsData.clipSpreadSheetURL = defaultClipSpreadSheetURL
		}
		else if (typeof settingsData.clipSpreadSheetURL == 'string') {
			if (settingsData.clipSpreadSheetURL.startsWith(SheetHeader)) {
				settingsData.clipSpreadSheetURL = settingsData.clipSpreadSheetURL.substring(SheetHeader.length)
			}
			settingsData.clipSpreadSheetURL = [settingsData.clipSpreadSheetURL]
		}
	}
	
	divClipSpreadSheetURL.replaceChildren();
	spreadsheetsFormList = []
	for (let i = 0; i < settingsData.clipSpreadSheetURL.length; ++i) {
		settings_AddURL(settingsData.clipSpreadSheetURL[i])
	}

	if (individualVolumeData) {
		for (let i = 0; i < individualVolumeData.length; ++i) {
			let data = individualVolumeData[i]
			individualVolumeMap.set(data[0], data[1])
		}
	}

	if (settingsData.clipSpreadSheetURL.length > 0) {
		google.charts.load('current', { packages: ['corechart'] }).then(function () {
			videoClipList = new Array()
			const URL = SheetHeader + settingsData.clipSpreadSheetURL[0]
			var query = new google.visualization.Query(URL);
			query.send(function(response) { readData_LoadSheet(URL, response.getDataTable(), 0) });
		});
	} else {
		readData_Finalize();
	}
}
function StringToArray(str)
{
	const length = str.length;
	const Array = new Uint8Array(length);
	for (let i = 0; i < length; i++) {
		Array[i] = str.charCodeAt(i);
	}
	return Array;
}
function ArrayToString(uint8Array) {
  let str = '';
  for (let i = 0; i < uint8Array.length; i++) {
    str += String.fromCharCode(uint8Array[i]);
  }
  return str;
}
function base64UrlEncode(input) {
  var base64 = btoa(input);
  return base64.replace(/\+/g, '.').replace(/\//g, '_').replace(/=/g, '-');
}

function base64UrlDecode(input) {
  input = input.replace(/\./g, '+').replace(/_/g, '/').replace(/-/g, '=');
  while (input.length % 4) {
    input += '=';
  }
  return atob(input);
}
function init() {
	window.addEventListener('beforeunload', (event) => {
		let state = player_getPlayerState()
		if (state == YT.PlayerState.PLAYING || state == YT.PlayerState.BUFFERING) {
			if (!confirm('Are you sure you want close window?')) {
				event.preventDefault();
				event.returnValue = '';
			}
		}
	});
/*
	const urlParameter = window.location.search;
	const urlParams = new URLSearchParams(urlParameter);
	const importStr = urlParams.get('a');
	if (importStr != null && importStr.length)
	{
		const importBinaryStr = base64UrlDecode(importStr);
		const DataBinary = StringToArray(importBinaryStr);
		const decoder = new TextDecoder();
		const DataStr = decoder.decode(DataBinary);

		let importData = {
			"playListData" : {},
			"individualVolumeData" : {},
			"settings" : {}
		};
		
		try {
			importData = JSON.parse(DataStr)
		} catch(err) {
		}
		localStorage.setItem("watamePlayer_PlayList", JSON.stringify(importData["playListData"]))
		localStorage.setItem("watamePlayer_Volumes", JSON.stringify(importData["individualVolumeData"]))
		localStorage.setItem("watamePlayer_settings", JSON.stringify(importData["settings"]))
	}
*/
	readData()
	//alert(navigator.userAgent)
	//alert(isMobile.any() != null)
	prevButton.innerHTML = '\u23ea'
	nextButton.innerText = '\u23e9'

	let totalListHeaders = [
		{ name:'Ordinal', width:88, id:'ordinal', filter:true, sort:true, numeric:true },
		{ name:'Date', width:110, id:'date', filter:true, sort:true },
		{ name:'Track Name', width:400, id:'trackName', filter:true, sort:true, autoSize:true },
		{ name:'Original Artist', width:160, id:'originalArtist', filter:true, sort:true },
		{ name:'Covered By', width:128, id:'coveredBy', filter:true, sort:true },
		{ name:'Category', width:120, id:'category', filter:true, sort:true },
		{ name:'Start', width:80, id:'start' },
		{ name:'End', width:80, id:'end' },
		{ name:'Used', width:80, id:'refCount', filter:true, sort:true },
		{ name:'ID', width:120, id:'ID', filter:true, sort:true },
		{ name:'Link', width:120, getter:function(d) { return getLink(d) } },
		{ name:'IndividualVolume', width:150, filter:true, sort:true, numeric:true, getter:function(d) { return isUndefined(individualVolumeMap.get(d.key), 0) } },
	]
	videoClipTable = new MultiColumnList(totalList)
	videoClipTable.selectMode = isMobile.any() != null
	videoClipTable.mainDivClassName = 'tblWrap'
	videoClipTable.headerDivClassName = 'userTblHead'
	videoClipTable.bodyDivClassName = 'userTbl'
	videoClipTable.ondblclick = function(e) {
		totalList_playVideo(this.selectedDataIndex)
	}

	videoClipTable.onkeydown = function(e) {
		if (e.keyCode == 13 && showPlaylistItems.checked) {
		   totalList_addSelectedToPlaylist()
		} else if (e.ctrlKey && e.keyCode == 67) {
			copySelectedItemsToClipboard(videoClipTable)
		}
	}
	videoClipTable.draggable = true
	videoClipTable.ondragstart = function(e, dataKey) {
		let keys = videoClipTable.selectedDataKeys
		let data = JSON.stringify(keys)
		e.dataTransfer.setData("wnfvideoclip", data);
		e.dataTransfer.dropEffect = "copy"
	}
	videoClipTable.oncontextmenu = function(event, d) {
		event.preventDefault()
		totalListContextMenu.show(event.clientX, event.clientY)
	}
	
	let playListDetailHeaders = [
		{ name:'', width:40, getter:function(d) {
			for (let i = 0; i < playContextStack.length; ++i) {
				if (d.key == playContextStack[i].currentPlayingItem.key) {
					return '\u25b6'
				}
			}
			if (viewContextStack.length > 0 && viewContextStack[viewContextStack.length - 1].currentPlayingItem && d.key == viewContextStack[viewContextStack.length - 1].currentPlayingItem.key) {
				return '\u25b7'
			}
			return ''
		}},
		{ name:'Order', width:80, title:"Play Order", filter:true, sort:true, numeric:true, getter:function(d) {
			return currentViewContext.playOrderMap.get(d.key) + 1
		}},
		{ name:'Type', width:80, filter:true, sort:true, getter:function(d) { return d.data.type == 1 ? 'ðŸŽ¶' : 'ðŸ“' } },
		{ name:'Date', width:110, filter:true, sort:true, getter:function(d) { return d.data.date } },
		{ name:'Track Name', width:400, filter:true, sort:true, getter:function(d) { return d.data.trackName }, autoSize:true },
		{ name:'Original Artist', width:160, filter:true, sort:true, getter:function(d) { return d.data.originalArtist } },
		{ name:'Covered By', width:128, filter:true, sort:true, getter:function(d) { return d.data.coveredBy } },
		{ name:'Category', width:120, filter:true, sort:true, getter:function(d) { return d.data.category } },
		{ name:'ShufflePriority', width:150, filter:true, sort:true, numeric:true, getter:function(d) { return d.shufflePriority } },
		{ name:'Ordinal', width:88, id:'ordinal', filter:true, sort:true, numeric:true, getter:function(item) { return playListItem_getOrdinal(item) } },
	]
	playListItemsTable = new MultiColumnList(playListDetail)
	playListItemsTable.selectMode = isMobile.any() != null
	playListItemsTable.mainDivClassName = 'tblWrap'
	playListItemsTable.headerDivClassName = 'userTblHead'
	playListItemsTable.bodyDivClassName = 'userTbl'
	playListItemsTable.ondblclick = function(e) {
		playListItemsTable_playOrOpen(this.selectedDataKey, true)
	}
	playListItemsTable.onkeydown = function(e) {
		if (e.keyCode == 46) {
			playListItemsTable_deleteSelected()
		} else if (e.ctrlKey && e.keyCode == 67) {
			copySelectedItemsToClipboard(playListItemsTable)
		}
	}
	playListItemsTable.draggable = true
	playListItemsTable.ondragstart = function(e, dataKey) {
		let keys = playListItemsTable.selectedDataKeys
		let data = JSON.stringify(keys)
		e.dataTransfer.setData("wnfplayitem", data);
		e.dataTransfer.dropEffect = "move"
	}
	playListItemsTable.ondrop = function(e, dataKey, front) {
		e.preventDefault();
		let data
		if (data = e.dataTransfer.getData("wnfvideoclip")) {
			let keys = JSON.parse(data)
			if (keys.length == 0) {
				return
			}
			const playList = currentViewContext.data
			playListItemsTable.beginUpdate()
			for (let i = 0; i < keys.length; ++i) {
				let data = videoClipTable.getDataByKey(keys[i])
				let item = playList_insertItem(playList, data, dataKey, front)
				dataKey = item.key
				front = false
			}
			playListItemsTable.endUpdate()
			playListTable.updateList()
			videoClipTable.updateList()
			setDataChanged()
		} else if (data = e.dataTransfer.getData("wnfplayitem")) {
			let keys = JSON.parse(data)
			removeItemOnce(keys, dataKey)
			if (keys.length == 0) {
				return
			}
			//console.log(keys)
			playListItemsTable.beginUpdate()
			let deletedDataList = playListItemsTable.deleteDataByKeys(keys)
			playListItemsTable.insertDataList(deletedDataList, dataKey, front)
			playListItemsTable.endUpdate()
			setDataChanged()
		} else if (data = e.dataTransfer.getData("wnfplaylist")) {
			let keys = JSON.parse(data)
			if (keys.length == 0) {
				return
			}
			const playList = currentViewContext.data
			playListItemsTable.beginUpdate()
			for (let i = 0; i < keys.length; ++i) {
				let data = playListTable.getDataByKey(keys[i])
				let item = playList_insertItem(playList, data, dataKey, front)
				dataKey = item.key
				front = false
			}
			playListItemsTable.endUpdate()
			playListTable.updateList()
			videoClipTable.updateList()
			setDataChanged()
		}
		playListItemsTable_updatePlayOrder()
	}
	playListItemsTable.ondragover = function(e, dataKey) {
		let types = e.dataTransfer.types
		for (let i = 0; i < types.length; ++i) {
			if (types[i] == "wnfvideoclip" || types[i] == 'wnfplayitem' || types[i] == 'wnfplaylist') {
				e.preventDefault()
				return true
			}
		}
		return false
	}
	playListItemsTable.ondragenter = function(e, dataKey) {
		let types = e.dataTransfer.types
		for (let i = 0; i < types.length; ++i) {
			if (types[i] == "wnfvideoclip" || types[i] == 'wnfplayitem' || types[i] == 'wnfplaylist') {
				e.preventDefault()
				return
			}
		}
	}
	playListItemsTable.ondragleave = function(e, dataKey) {
		let types = e.dataTransfer.types
		for (let i = 0; i < types.length; ++i) {
			if (types[i] == "wnfvideoclip" || types[i] == 'wnfplayitem' || types[i] == 'wnfplaylist') {
				e.preventDefault()
				return
			}
		}
	}
	playListItemsTable.onSorted = function(t) {
		playListItemsTable_updatePlayOrder()
		setDataChanged()
	}
	playListItemsTable.oncontextmenu = function(event, d) {
		event.preventDefault()
		playListItemsContextMenu.show(event.clientX, event.clientY)
	}
	
	let playListHeaders = [
		{ name:'', width:40, getter:function(d) {
			if (d.key == currentViewContext.data.key) {
				for (let i = 0; i < playContextStack.length; ++i) {
					if (d.key == playContextStack[i].data.key) {
						return '\u25b6'
					}
				}	
			}
			return ''
		}},
		{ name:'Date', width:110, id:'date', filter:true, sort:true },
		{ name:'Track Name', width:400, filter:true, sort:true, id:'trackName', autoSize:true },
		{ name:'Category', width:120, filter:true, sort:true, id:'category' },
		{ name:'Original Artist', width:160, filter:true, sort:true, id:'originalArtist' },
		{ name:'Covered By', width:128, id:'coveredBy', filter:true, sort:true },
		{ name:'Shuffle', width:88, filter:true, sort:false, getter:function(d) { return d.shuffle ? '1' : '0' } },
		{ name:'PlayAll', width:88, filter:true, sort:false, getter:function(d) { return d.entirePlay ? '1' : '0' } },
		{ name:'Count', width:100, filter:true, sort:true, numeric:true, getter:function(d) { return d.items.length } },
		{ name:'Used', width:80, id:'refCount', filter:true, sort:true },
	]
	playListTable = new MultiColumnList(playList)
	playListTable.selectMode = isMobile.any() != null
	playListTable.mainDivClassName = 'tblWrap'
	playListTable.headerDivClassName = 'userTblHead'
	playListTable.bodyDivClassName = 'userTbl'
	playListTable.ondblclick = function(e) {
		playList_open(this.getDataByKey(this.selectedDataKey))
	}
	
	playListTable.onkeydown = function(e) {
		if (e.keyCode == 46) {
			playListTable_deleteSelected()
		} else if (e.keyCode == 13) {
		   playList_addSelectedToPlayListItems()
		} else if (e.ctrlKey && e.keyCode == 67) {
			copySelectedItemsToClipboard(playListTable)
		}
	}
	playListTable.draggable = true
	playListTable.ondragstart = function(e, dataKey) {
		let keys = playListTable.selectedDataKeys
		let data = JSON.stringify(keys)
		e.dataTransfer.setData("wnfplaylist", data);
		e.dataTransfer.dropEffect = "copy"
	}
	playListTable.ondrop = function(e, dataKey, front) {
		e.preventDefault();
		let data
		if (data = e.dataTransfer.getData("wnfvideoclip")) {
			let keys = JSON.parse(data)
			if (keys.length == 0) {
				return
			}
			const playList = playListTable.getDataByKey(dataKey)
			playListItemsTable.beginUpdate()
			for (let i = 0; i < keys.length; ++i) {
				let data = videoClipTable.getDataByKey(keys[i])
				let item = playList_insertItem(playList, data)
			}
			playListItemsTable.endUpdate()
			videoClipTable.updateList()
			playListTable.updateList()
			setDataChanged()
		} else if (data = e.dataTransfer.getData("wnfplayitem")) {
			let keys = JSON.parse(data)
			if (keys.length == 0) {
				return
			}
			const playList = playListTable.getDataByKey(dataKey)
			if (playList != currentViewContext.data) {
				playListItemsTable.beginUpdate()
				for (let i = 0; i < keys.length; ++i) {
					let item = playListItemsTable.getDataByKey(keys[i])
					playList_insertItem(playList, item.data)
				}
				playListItemsTable.endUpdate()
				videoClipTable.updateList()
				playListTable.updateList()
				setDataChanged()
				updatePlayerOrder()
			}
		} else if (data = e.dataTransfer.getData("wnfplaylist")) {
			let keys = JSON.parse(data)
			removeItemOnce(keys, dataKey)
			if (keys.length == 0) {
				return
			}
			//console.log(keys)
			playListTable.beginUpdate()
			let deletedDataList = playListTable.deleteDataByKeys(keys)
			playListTable.insertDataList(deletedDataList, dataKey, front)
			playListTable.endUpdate()
			setDataChanged()
		}
		playListItemsTable_updatePlayOrder()
	}
	playListTable.ondragover = function(e, dataKey) {
		let types = e.dataTransfer.types
		for (let i = 0; i < types.length; ++i) {
			if (types[i] == "wnfvideoclip" || types[i] == 'wnfplayitem') {
				e.preventDefault()
				return 2
			}
			if (types[i] == 'wnfplaylist') {
				e.preventDefault()
				return 1
			}
		}
		return false
	}
	playListTable.ondragenter = function(e, dataKey) {
		let types = e.dataTransfer.types
		for (let i = 0; i < types.length; ++i) {
			if (types[i] == "wnfvideoclip" || types[i] == 'wnfplayitem' || types[i] == 'wnfplaylist') {
				e.preventDefault()
				return
			}
		}
	}
	playListTable.ondragleave = function(e, dataKey) {
		let types = e.dataTransfer.types
		for (let i = 0; i < types.length; ++i) {
			if (types[i] == "wnfvideoclip" || types[i] == 'wnfplayitem' || types[i] == 'wnfplaylist') {
				e.preventDefault()
				return
			}
		}
	}
	playListTable.oncontextmenu = function(event, d) {
		event.preventDefault()
		playListContextMenu.show(event.clientX, event.clientY)
	}
	videoClipTable.setHeader(totalListHeaders)
	playListTable.setHeader(playListHeaders)				
	playListItemsTable.setHeader(playListDetailHeaders)
	
	updateDivVisible()
	videoControl.step = 1
	volumeControl.min = 0
	volumeControl.max = 100
	volumeControl.step = 1
	individualVolume.min = 0
	individualVolume.max = 100
	individualVolume.step = 1				
	
	{
		totalListContextMenu = new PopupMenu()
		totalListContextMenu.className = 'contextMenuDiv'
		totalListContextMenu.itemNormalClassName = 'contextMenuDivItemNormal'
		totalListContextMenu.itemHoverClassName = 'contextMenuDivItemHover'
		let itemPlay = totalListContextMenu.addItem()
		itemPlay.setElements('Play')
		itemPlay.onclick = function() {
			totalList_playVideo(videoClipTable.selectedDataIndex)
		}

		let itemSearch = totalListContextMenu.addItem()
		itemSearch.setElements('Search for Playlists Containing Item')
		itemSearch.onclick = function() {
			showPlaylist.checked = true
			updateDivVisible()
			playListTable_SearchByItemKey(videoClipTable.getDataByKey(videoClipTable.selectedDataKey).key)
		}
	}
	{
		playListContextMenu = new PopupMenu()
		playListContextMenu.className = 'contextMenuDiv'
		playListContextMenu.itemNormalClassName = 'contextMenuDivItemNormal'
		playListContextMenu.itemHoverClassName = 'contextMenuDivItemHover'
		let itemSelect = playListContextMenu.addItem()
		itemSelect.setElements('Select')
		itemSelect.onclick = function() {
			playList_open(playListTable.getDataByKey(playListTable.selectedDataKey))
		}
		let itemSearch = playListContextMenu.addItem()
		itemSearch.setElements('Search for Playlists Containing Item')
		itemSearch.onclick = function() {
			let data = playListTable.getDataByKey(playListTable.selectedDataKey)
			playListTable_SearchByItemKey(data.key)
		}
		let itemEdit = playListContextMenu.addItem()
		itemEdit.setElements('Edit')
		itemEdit.onclick = function() {
			playList_editPanel()
		}
		let itemClone = playListContextMenu.addItem()
		itemClone.setElements('Clone')
		itemClone.onclick = function() {
			playList_clonePanel()
		}
		let itemDelete = playListContextMenu.addItem()
		itemDelete.setElements('Delete')
		itemDelete.onclick = function() {
			playListTable_deleteSelected()
		}
		let itemMoveToFront = playListContextMenu.addItem()
		itemMoveToFront.setElements('Move to front')
		itemMoveToFront.onclick = function() {
			playListTable_moveToFront()
		}
		let itemMoveToBack = playListContextMenu.addItem()
		itemMoveToBack.setElements('Move to back')
		itemMoveToBack.onclick = function() {
			playListTable_moveToBack()
		}
		
		let itemPlaylistTask = playListContextMenu.addItem()
		itemPlaylistTask.setElements(createSpan('Playlist Task', 'flex:1;'), createSpan('>', 'flex:none;'))
		let menuPlaylistTask = itemPlaylistTask.setSubMenu()
		let itemCheckShuffle = menuPlaylistTask.addItem()
		itemCheckShuffle.setElements('Set shuffle on')
		itemCheckShuffle.onclick = function() {
			playListTable_ForeachSelection(function(data) {
				data.shuffle = true
			})
			playList_updateCheckboxes()
		}
		let itemUncheckShuffle = menuPlaylistTask.addItem()
		itemUncheckShuffle.setElements('Set shuffle off')
		itemUncheckShuffle.onclick = function() {
			playListTable_ForeachSelection(function(data) {
				data.shuffle = false
			})
			playList_updateCheckboxes()
		}
		let itemCheckPlayEntire = menuPlaylistTask.addItem()
		itemCheckPlayEntire.setElements('Set playEntireItems on')
		itemCheckPlayEntire.onclick = function() {
			playListTable_ForeachSelection(function(data) {
				data.entirePlay = true
			})
			playList_updateCheckboxes()
		}
		let itemUncheckPlayEntire = menuPlaylistTask.addItem()
		itemUncheckPlayEntire.setElements('Set playEntireItems off')
		itemUncheckPlayEntire.onclick = function() {
			playListTable_ForeachSelection(function(data) {
				data.entirePlay = false
			})
			playList_updateCheckboxes()
		}
	}
	{
		playListItemsContextMenu = new PopupMenu()
		playListItemsContextMenu.className = 'contextMenuDiv'
		playListItemsContextMenu.itemNormalClassName = 'contextMenuDivItemNormal'
		playListItemsContextMenu.itemHoverClassName = 'contextMenuDivItemHover'
		let itemPlay = playListItemsContextMenu.addItem()
		itemPlay.setElements('Play')
		itemPlay.onclick = function() {
			playListItemsTable_play(playListItemsTable.selectedDataKey)
		}
		let itemOpen = playListItemsContextMenu.addItem()
		itemOpen.setElements('Open')
		itemOpen.onclick = function() {
			playListItemsTable_playOrOpen(playListItemsTable.selectedDataKey, false)
		}
		let itemSearch = playListItemsContextMenu.addItem()
		itemSearch.setElements('Search for Playlists Containing Item')
		itemSearch.onclick = function() {
			let data = playListItemsTable.getDataByKey(playListItemsTable.selectedDataKey).data
			showPlaylist.checked = true
			updateDivVisible()
			playListTable_SearchByItemKey(data.key)
		}
		let itemSelect = playListItemsContextMenu.addItem()
		itemSelect.setElements('Select')
		itemSelect.onclick = function() {
			let data = playListItemsTable.getDataByKey(playListItemsTable.selectedDataKey).data
			if (data.type == 1)
			{
				showTotallist.checked = true
			}
			else if (data.type == 2)
			{
				showPlaylist.checked = true
			}
			updateDivVisible()
			if (data.type == 1)
			{
				videoClipTable.scrollToRowByDataKey(data.key, true)
				videoClipTable.selectedDataKey = data.key
			}
			else if (data.type == 2)
			{
				playListTable.scrollToRowByDataKey(data.key, true)
				playListTable.selectedDataKey = data.key
			}
		}
		let itemDelete = playListItemsContextMenu.addItem()
		itemDelete.setElements('Delete')
		itemDelete.onclick = function() {
			playListItemsTable_deleteSelected()
		}
		let itemMoveToFront = playListItemsContextMenu.addItem()
		itemMoveToFront.setElements('Move to front')
		itemMoveToFront.onclick = function() {
			playListItemsTable_moveToFront()
		}
		let itemMoveToBack = playListItemsContextMenu.addItem()
		itemMoveToBack.setElements('Move to back')
		itemMoveToBack.onclick = function() {
			playListItemsTable_moveToBack()
		}
	
		let itemPlayOrderTask = playListItemsContextMenu.addItem()
		itemPlayOrderTask.setElements(createSpan('PlayOrder Task', 'flex:1;'), createSpan('>', 'flex:none;'))
		let menuPlayOrderTask = itemPlayOrderTask.setSubMenu()
		let itemShuffleSelections = menuPlayOrderTask.addItem()
		itemShuffleSelections.setElements('Shuffle Selection')
		itemShuffleSelections.onclick = function() {
			let selectedDataKeys = playListItemsTable.selectedDataKeys
			if (selectedDataKeys.length <= 1) {
				return
			}
			let ctx = currentViewContext
			const playOrder = ctx.playOrder
			const playOrderMap = ctx.playOrderMap
			const currentPlayingItem = ctx.currentPlayingItem
			let currentPlayingKeyIndex = undefined
			let indexes = []
			for (let i = 0; i < selectedDataKeys.length; ++i) {
				const key = selectedDataKeys[i]
				let orderIdx = playOrderMap.get(key)
				if (orderIdx != undefined) {
					if (currentPlayingItem.key == key) {
						currentPlayingKeyIndex = i
					}
					indexes.push(orderIdx)
				}
			}
			
			ctx.shuffled = true
			shuffle(indexes)
			if (currentPlayingKeyIndex != undefined) {
				let minValue = indexes[0]
				let minIndex = 0
				for (let i = 1; i < indexes.length; ++i) {
					if (minValue > indexes[i]) {
						minValue = indexes[i]
						minIndex = i
					}
				}
				let temp = indexes[minIndex]
				indexes[minIndex] = indexes[currentPlayingKeyIndex]
				indexes[currentPlayingKeyIndex] = temp
			}
			for (let i = 0; i < selectedDataKeys.length; ++i) {
				const key = selectedDataKeys[i]
				playOrder[indexes[i]] = playListItemsTable.getDataByKey(key)
				playOrderMap.set(key, indexes[i])
			}
		
			playListItemsTable.updateList()
			refreshControlPanel()
		}
		let itemReorderSelections = menuPlayOrderTask.addItem()
		itemReorderSelections.setElements('Reorder Selection')
		itemReorderSelections.onclick = function() {
			let selectedDataKeys = playListItemsTable.selectedDataKeys
			if (selectedDataKeys.length <= 1) {
				return
			}
			let ctx = currentViewContext
			const playOrder = ctx.playOrder
			const playOrderMap = ctx.playOrderMap
			let items = []
			let indexes = []
			for (let i = 0; i < selectedDataKeys.length; ++i) {
				const key = selectedDataKeys[i]
				let orderIdx = playOrderMap.get(key)
				if (orderIdx != undefined) {
					const rowIdx = playListItemsTable.getRowIndex(key)
					indexes.push(orderIdx)
					items.push({ key:key, rowIdx:rowIdx })
				}
			}
			
			items.sort(function(a,b) {
				return a.rowIdx - b.rowIdx
			})
			indexes.sort((a,b)=>a-b)
			for (let i = 0; i < items.length; ++i) {
				const key = items[i].key
				playOrder[indexes[i]] = playListItemsTable.getDataByKey(key)
				playOrderMap.set(key, indexes[i])
			}
		
			playListItemsTable.updateList()
			refreshControlPanel()
		}

		let itemPlayOrderMoveToFront = menuPlayOrderTask.addItem()
		itemPlayOrderMoveToFront.setElements('Move to front')
		itemPlayOrderMoveToFront.onclick = function() {
			let selectedDataKeys = playListItemsTable.selectedDataKeys
			if (selectedDataKeys.length <= 0) {
				return
			}

			let ctx = currentViewContext
			const playOrder = ctx.playOrder
			const playOrderMap = ctx.playOrderMap
			let items = []
			let indexes = []
			for (let i = 0; i < selectedDataKeys.length; ++i) {
				const key = selectedDataKeys[i]
				let orderIdx = playOrderMap.get(key)
				if (orderIdx != undefined) {
					const rowIdx = playListItemsTable.getRowIndex(key)
					indexes.push(orderIdx)
					items.push({ key:key, rowIdx:rowIdx })
				}
			}
			
			items.sort(function(a,b) {
				return b.rowIdx - a.rowIdx
			})

			indexes.sort((a,b)=>a-b)
			const movedItems = []
			for (let i = indexes.length - 1; i >= 0; --i) {
				let idx = indexes[i]
				playOrder.splice(idx, 1)
				movedItems.push(playListItemsTable.getDataByKey(items[i].key))
			}

			ctx.playOrder = movedItems.concat(playOrder)
			playContext_refreshPlayerOrderMap(ctx)
			
			playListItemsTable.updateList()
			refreshControlPanel()
		}
		let itemPlayOrderMoveToBack = menuPlayOrderTask.addItem()
		itemPlayOrderMoveToBack.setElements('Move to back')
		itemPlayOrderMoveToBack.onclick = function() {
			let selectedDataKeys = playListItemsTable.selectedDataKeys
			if (selectedDataKeys.length <= 0) {
				return
			}

			let ctx = currentViewContext
			const playOrder = ctx.playOrder
			const playOrderMap = ctx.playOrderMap
			let items = []
			let indexes = []
			for (let i = 0; i < selectedDataKeys.length; ++i) {
				const key = selectedDataKeys[i]
				let orderIdx = playOrderMap.get(key)
				if (orderIdx != undefined) {
					const rowIdx = playListItemsTable.getRowIndex(key)
					indexes.push(orderIdx)
					items.push({ key:key, rowIdx:rowIdx })
				}
			}
			
			items.sort(function(a,b) {
				return b.rowIdx - a.rowIdx
			})

			indexes.sort((a,b)=>a-b)
			const movedItems = []
			for (let i = indexes.length - 1; i >= 0; --i) {
				let idx = indexes[i]
				playOrder.splice(idx, 1)
				movedItems.push(playListItemsTable.getDataByKey(items[i].key))
			}

			ctx.playOrder = playOrder.concat(movedItems)
			playContext_refreshPlayerOrderMap(ctx)
			
			playListItemsTable.updateList()
			refreshControlPanel()
		}

		let itemPlaylistTask = playListItemsContextMenu.addItem()
		itemPlaylistTask.setElements(createSpan('Playlist Task', 'flex:1;'), createSpan('>', 'flex:none;'))
		let menuPlaylistTask = itemPlaylistTask.setSubMenu()
		let itemCheckShuffle = menuPlaylistTask.addItem()
		itemCheckShuffle.setElements('Set shuffle on')
		itemCheckShuffle.onclick = function() {
			playListItemsTable_ForeachSelection(function(item) {
				if (item.data.type == 2) {
					item.data.shuffle = true
				}
			})
			playList_updateCheckboxes()
		}
		let itemUncheckShuffle = menuPlaylistTask.addItem()
		itemUncheckShuffle.setElements('Set shuffle off')
		itemUncheckShuffle.onclick = function() {
			playListItemsTable_ForeachSelection(function(item) {
				if (item.data.type == 2) {
					item.data.shuffle = false
				}
			})
			playList_updateCheckboxes()
		}
		let itemCheckPlayEntire = menuPlaylistTask.addItem()
		itemCheckPlayEntire.setElements('Set playEntireItems on')
		itemCheckPlayEntire.onclick = function() {
			playListItemsTable_ForeachSelection(function(item) {
				if (item.data.type == 2) {
					item.data.entirePlay = true
				}
			})
			playList_updateCheckboxes()
		}
		let itemUncheckPlayEntire = menuPlaylistTask.addItem()
		itemUncheckPlayEntire.setElements('Set playEntireItems off')
		itemUncheckPlayEntire.onclick = function() {
			playListItemsTable_ForeachSelection(function(item) {
				if (item.data.type == 2) {
					item.data.entirePlay = false
				}
			})
			playList_updateCheckboxes()
		}
		/*
		let itemTest1 = playListItemsContextMenu.addItem()
		itemTest1.setElements(createSpan('Test1 Task', 'flex:1;'), createSpan('>', 'flex:none;'))

		let menuTest1Task = itemTest1.setSubMenu()
		let menuTest1 = menuTest1Task.addItem()
		menuTest1.setElements(createSpan('Test2 Task', 'flex:1;'), createSpan('>', 'flex:none;'))
		let menuTest2Task = menuTest1.setSubMenu()
		let menuSubTest1 = menuTest2Task.addItem()
		menuSubTest1.setElements('Set playEntireItems on')

		let menuTest3 = menuTest1Task.addItem()
		menuTest3.setElements(createSpan('Test3 Task', 'flex:1;'), createSpan('>', 'flex:none;'))
		let menuTest3Task = menuTest3.setSubMenu()
		let menuSubTest2 = menuTest3Task.addItem()
		menuSubTest2.setElements('Set playEntireItems on')
		*/
	}
}
function makeSearchText(value) {
	value.searchTexts = [isUndefined(value.category, ''), isUndefined(value.date, ''), isUndefined(value.trackName, ''), isUndefined(value.originalArtist, ''), isUndefined(value.coveredBy, '')]
	value.searchLowerCaseTexts = []
	for (let i = 0; i < value.searchTexts.length; ++i) {
		value.searchLowerCaseTexts.push(value.searchTexts[i].toLowerCase())
	}
}
function playList_getOrdinal(playList) {
	return playList.items.length == 0
		? ''
		: playListItem_getOrdinal(playList.items[0])
}
function playListItem_getOrdinal(item) {
	return item.data.type == 2
		? playList_getOrdinal(item.data)
		: item.data.ordinal
}
function playList_open(playList) {
	array_clear(viewContextStack)
	playList_push(playList)
}
function playList_selectAll() {
	playListTable.selectAll()
}
function playList_clearAll() {
	playListTable.clearSelection()
}
function playList_push(playList) {
	viewContextStack.push(playContext_get(playList))
	playList_setPage(playList)
}
function playList_setPage(playList) {
	currentViewContext = playContext_get(playList)
	playListItemsTable.setData(playList.items)
	playList_checkBoxShuffle.checked = playList.shuffle
	playList_checkBoxPlayEntireList.checked = playList.entirePlay
	playListTable.updateList()
	refreshControlPanel()
}
function playListTable_ForeachSelection(func) {
	let selectedDataKeys = playListTable.selectedDataKeys
	if (selectedDataKeys.length == 0) {
		return
	}
	for (let i = 0; i < selectedDataKeys.length; ++i) {
		let item = playListTable.getDataByKey(selectedDataKeys[i])
		func(item)
	}
	playListTable.updateList()
	refreshControlPanel()
	setDataChanged()
}
function playListItemsTable_ForeachSelection(func) {
	let selectedDataKeys = playListItemsTable.selectedDataKeys
	if (selectedDataKeys.length == 0) {
		return
	}
	for (let i = 0; i < selectedDataKeys.length; ++i) {
		let item = playListItemsTable.getDataByKey(selectedDataKeys[i])
		func(item)
	}
	playListItemsTable.updateList()
	refreshControlPanel()
	setDataChanged()
}
function playListTable_deleteSelected() {
	let selectedDataKeys = playListTable.selectedDataKeys
	if (selectedDataKeys.length == 0) {
		return
	}
	playListTable.beginUpdate()
	let dataList = playListTable.deleteSelection()
	for (let i = 0; i < dataList.length; ++i) {
		dataList[i].deleted = true
		playList_itemsDeleted(dataList[i].items)
		playContextMap.delete(dataList[i].key)
	}
	playListTable.endUpdate()
	
	const playLists = playListTable.dataList
	for (let i = 0; i < playLists.length; ++i) {
		const items = playLists[i].items
		for (let j = items.length - 1; j >= 0; --j) {
			const item = items[j]
			if (item.data.deleted) {
				playList_itemsDeleted(item)
				items.splice(j, 1)
			}
		}
	}
	
	let deleted = false
	for (let i = 0; i < viewContextStack.length; ++i) {
		if (viewContextStack[i].data.deleted) {
			if (i > 0) {
				viewContextStack.splice(i, viewContextStack.length)
				const ctx = viewContextStack[viewContextStack.length - 1]
				playList_setPage(ctx.data)
				playListItemsTable.selectedDataKey = ctx.currentViewingItem.key
			} else {
				array_clear(viewContextStack)
				playListItemsTable.setData([])
			}
			deleted = true
			break
		}
	}
	if (!deleted) {
		playListItemsTable.refreshList()
	}
	videoClipTable.updateList()
	
	for (let i = 0; i < playContextStack.length; ++i) {
		if (playContextStack[i].data.deleted) {
			common_stopVideo(false)
			break
		}
	}
	playListTable.focus()
	refreshControlPanel()
	setDataChanged()
}
function playListTable_deleteAll(bSave = true) {
	if (playContextStack.length != 0) {
		common_stopVideo(false)
	}
	
	playListTable.setData([])
	playListItemsTable.setData([])
	playContextMap.clear()
	array_clear(playContextStack)
	array_clear(viewContextStack)
	for (let i = 0; i < videoClipList.length; ++i) {
		videoClipList[i].refCount = 0
	}
	videoClipTable.updateList()
	refreshControlPanel()
	if (bSave) {
		setDataChanged()
	}
}
function playContext_get(playList) {
	let ctx = playContextMap.get(playList.key)
	if (!ctx) {
		ctx = { data:playList, currentPlayingItem:undefined, currentViewingItem:undefined, playOrder:[], playOrderMap:new Map(), shuffled:false }
		playContext_resetPlayOrder(ctx)
		if (playList.shuffle) {
			ctx.shuffled = true
			playContext_shufflePlayOrder(ctx)
		}
		playContextMap.set(playList.key, ctx)
	}
	return ctx
}
function setDataChanged() {
	dataChanged = true
	playList_save()
}
function settings_getJson() {
	let newClipSpreadSheetURL = []
	for (let i = 0; i < spreadsheetsFormList.length; ++i) {
		const value = spreadsheetsFormList[i].value
		if (value.length == 0) {
			continue
		}
		newClipSpreadSheetURL.push(value)
	}
	let settings = {}
	if (newClipSpreadSheetURL.length == 0) {
		newClipSpreadSheetURL = defaultClipSpreadSheetURL
	}
	settings.clipSpreadSheetURL = newClipSpreadSheetURL
	return settings
}
function settings_save() {
	localStorage.setItem("watamePlayer_settings", JSON.stringify(settings_getJson()))
	playListTable_deleteAll(false)
	readData();
}
function settings_newURL() {
	settings_AddURL('')
}
let playListSN = 1
function playList_new() {
	let key = Date.now() * 1000 + (playListSN++ % 1000)
	const item = { type:2, key:key.toString(16), items:[], category:"", trackName:"", originalArtist:"", coveredBy:"", date:'', shuffle:true, entirePlay:false, refCount:0 }
	makeSearchText(item)
	return item
}
function playList_load(data) {
	const item = { type:2, key:data.key, items:[], category:data.category, trackName:data.trackName, originalArtist:data.originalArtist, coveredBy:data.coveredBy, date:data.date, shuffle:data.shuffle, entirePlay:data.entirePlay, refCount:0 }
	if (item.singer == undefined) {
		item.singer = ''
	}
	makeSearchText(item)
	return item
}
function refreshControlPanel() {
	const sufflePlayList = currentViewContext ? currentViewContext.shuffled : false
	suffleIcon.style.opacity = sufflePlayList ? 1 : .4
	suffleButton.title = sufflePlayList ? 'shuffled' : 'not shuffled'
	if (modePlayList == 0) {
		modeIcon.innerHTML = 'ðŸ”'
		modeIcon.style.opacity = .4
		modeButton.title = 'no repeat'
	} else if (modePlayList == 1) {
		modeIcon.innerHTML = 'ðŸ”'
		modeIcon.style.opacity = 1
		modeButton.title = 'repeat track'
	} else if (modePlayList == 2) {
		modeIcon.innerHTML = 'ðŸ”‚'
		modeIcon.style.opacity = 1
		modeButton.title = 'repeat video'
	}

	let isPlayingContext = false
	for (let i = 0; i < playContextStack.length; ++i) {
		if (playContextStack[i] == currentViewContext) {
			isPlayingContext = true
			break
		}
	}
	if (isPlayingContext && currentViewContext.currentPlayingItem) {
		const currentPlayingItem = currentViewContext.currentPlayingItem
		const playOrder = currentViewContext.playOrder
		const playOrderMap = currentViewContext.playOrderMap
		const idx = playOrderMap.get(currentPlayingItem.key)
		currentOrder.innerHTML = '(' + (idx + 1) + ' / ' + playOrder.length + ')'
	} else {
		currentOrder.innerHTML = ''
	}

	if (currentVideoClip) {
		currentSong.innerHTML = currentVideoClip.trackName + ' / ' + currentVideoClip.originalArtist
	} else {
		currentSong.innerHTML = ''
	}
	
	//removeAllChildNodes(divViewPath)
	divViewPath.replaceChildren()
	for (let i = 0; i < viewContextStack.length; ++i) {
		if (i != 0) {
			const label = document.createElement('label')
			label.appendChild(document.createTextNode('->'))
			divViewPath.appendChild(label)
		}
		let data = viewContextStack[i].data
		let anchor = document.createElement('a')
		anchor.innerHTML = `[${data.trackName} / ${data.originalArtist}]`
		anchor.href = '#'
		anchor.onclick = function(e) {
			e.preventDefault()
			const idx = i + 1
			if (viewContextStack.length >= idx) {
				viewContextStack.splice(idx, viewContextStack.length)
				const ctx = viewContextStack[viewContextStack.length - 1]
				playList_setPage(ctx.data)
				playListItemsTable.selectedDataKey = ctx.currentViewingItem.key
			}
		}
		divViewPath.appendChild(anchor)
	}
	
	//removeAllChildNodes(divPlayPath)
	divPlayPath.replaceChildren()
	for (let i = 0; i < playContextStack.length; ++i) {
		if (i != 0) {
			const label = document.createElement('label')
			label.appendChild(document.createTextNode('->'))
			divPlayPath.appendChild(label)
		}
		let data = playContextStack[i].data
		let anchor = document.createElement('a')
		anchor.innerHTML = `[${data.trackName} / ${data.originalArtist}]`
		anchor.href = '#'
		anchor.onclick = function(e) {
			e.preventDefault()
			playContext_copyFromPlay()
			const idx = i + 1
			if (viewContextStack.length >= idx) {
				viewContextStack.splice(idx, viewContextStack.length)
				const ctx = viewContextStack[viewContextStack.length - 1]
				playList_setPage(ctx.data)
				playListItemsTable.selectedDataKey = ctx.currentViewingItem.key
			}
		}
		divPlayPath.appendChild(anchor)
	}				
	
	const useIndividualVolume = currentVideoClip && individualVolumeMap.has(currentVideoClip.key)
	individualVolume.checked = useIndividualVolume
	individualVolumeControl.disabled = !useIndividualVolume
	volumeText.innerHTML = volumeControl.value + "%"
	if (!useIndividualVolume) {
		individualVolumeControl.value = volumeControl.value
		individualVolumeText.innerHTML = volumeControl.value + "%"
	}
	refreshPlayButton()
}
function copySelectedItemsToClipboard(list) {
	let keys = list.selectedDataKeys
	let headers = list.headers
	let text = ''
	for (let i = 0; i < keys.length; ++i) {
		let key = keys[i]
		let data = list.getDataByKey(key)
		for (let j = 0; j < headers.length; ++j) {
			if (j != 0) {
				text += '\t'
			}
			let header = headers[j]
			let value = header_getData(header, data)
			text += value
		}
		text += '\n'
	}
	if (text.length == 0) {
		return
	}
	const t = document.createElement("textarea");
	document.body.appendChild(t);
	t.value = text;
	t.select();
	document.execCommand('copy');
	document.body.removeChild(t);
	list.focus()
}
let nextPlayItemSN = 1
function playList_newItem(playList, data, shufflePriority) {
	let newKey = nextPlayItemSN++
	let item = { key:newKey, playList:playList, data:data, shufflePriority:isUndefined(shufflePriority, 0) }
	++data.refCount
	playList.items.push(item)
	return item
}
function playList_insertItem(playList, data, atDataKey=null, front=false) {
	let newKey = nextPlayItemSN++
	if (playList == null) {
		playList = currentViewContext.data
	}
	let item = { key:newKey, playList:playList, data:data, shufflePriority:0 }
	++data.refCount

	if (currentViewContext.data == dList) {
		let ctx = currentViewContext
		const playOrder = ctx.playOrder
		const playOrderMap = ctx.playOrderMap
		playOrderMap.set(item.key, playOrder.length)
		playOrder.push(item)
		playListItemsTable.insertData(item, atDataKey, front)
	} else {
		let ctx = playContext_get(playList)
		if (atDataKey != null) {
			const idx = playList.items.indexOf(atDataKey)
			if (idx == -1 || front) {
				playList.items.splice(idx, 0, item)
			} else {
				playList.items.splice(idx + 1, 0, item)
			}
		} else {
			playList.items.push(item)
		}
		const playOrder = ctx.playOrder
		const playOrderMap = ctx.playOrderMap
		playOrderMap.set(item.key, playOrder.length)
		playOrder.push(item)
	}
	
	return item
}
function playList_insertItems(playList, datas, atDataKey=null, front=false) {
	if (playList == null) {
		playList = currentViewContext.data
	}
	let items = []
	for (let i = 0; i < datas.length; ++i) {
		let data = datas[i]
		items.push({ key:nextPlayItemSN++, playList:playList, data:data, shufflePriority:0 })
		++data.refCount
		}
	
	if (currentViewContext.data == playList) {
		let ctx = currentViewContext
		const playOrder = ctx.playOrder
		const playOrderMap = ctx.playOrderMap
		playOrderMap.set(item.key, playOrder.length)
		playOrder.push(item)
		playListItemsTable.insertDataList(items, atDataKey, front)
	} else {
		let ctx = playContext_get(playList)
		if (atDataKey != null) {
			const idx = playList.items.indexOf(atDataKey)
			if (idx == -1) {
				for (let i = 0; i < items.length; ++i) {
					playList.items.push(items[i])
				}
			} else if (front) {
				for (let i = 0; i < items.length; ++i) {
					playList.items.splice(idx + i, 0, items[i])
				}
			} else {
				for (let i = 0; i < items.length; ++i) {
					playList.items.splice(idx + i + 1, 0, items[i])
				}
			}
		} else if (front) {
			for (let i = 0; i < items.length; ++i) {
				playList.items.splice(i, 0, item)
			}						
		} else {
			for (let i = 0; i < items.length; ++i) {
				playList.items.push(items[i])
			}
		}
		const playOrder = ctx.playOrder
		const playOrderMap = ctx.playOrderMap
		playOrderMap.set(item.key, playOrder.length)
		playOrder.push(item)
	}
	return item
}
function playList_insertItems(playList, mayDataList, atDataKey=null, front=false) {
	let ctx = currentViewContext
	let currentPlayList = currentViewContext.data
	if (playList == null) {
		playList = currentPlayList
	}
	let items = []
	if (Array.isArray(mayDataList)) {
		for (let i = 0; i < mayDataList.length; ++i) {
			let data = mayDataList[i]
			items.push({ key:nextPlayItemSN++, playList:playList, data:data, shufflePriority:0 })
			++data.refCount
			}
	} else {
		items.push({ key:nextPlayItemSN++, playList:playList, data:mayDataList, shufflePriority:0 })
		++mayDataList.refCount
	}
	
	if (currentPlayList == playList) {
		const playOrder = ctx.playOrder
		const playOrderMap = ctx.playOrderMap
		for (let i = 0; i < items.length; ++i) {
			const item = items[i]
			playOrderMap.set(item.key, playOrder.length)
			playOrder.push(item)
		}
		playListItemsTable.insertDataList(items, atDataKey, front)
	} else {
		if (atDataKey != null) {
			const idx = playList.items.indexOf(atDataKey)
			if (idx == -1) {
				for (let i = 0; i < items.length; ++i) {
					playList.items.push(items[i])
				}
			} else if (front) {
				for (let i = 0; i < items.length; ++i) {
					playList.items.splice(idx + i, 0, items[i])
				}
			} else {
				for (let i = 0; i < items.length; ++i) {
					playList.items.splice(idx + i + 1, 0, items[i])
				}
			}
		} else if (front) {
			for (let i = 0; i < items.length; ++i) {
				playList.items.splice(i, 0, items[i])
			}						
		} else {
			for (let i = 0; i < items.length; ++i) {
				playList.items.push(items[i])
			}
		}
		ctx = playContext_get(playList)
		const playOrder = ctx.playOrder
		const playOrderMap = ctx.playOrderMap
		for (let i = 0; i < items.length; ++i) {
			const item = items[i]
			playOrderMap.set(item.key, playOrder.length)
			playOrder.push(item)
		}
	}
	return items
}
function playList_itemsDeleted(items) {
	if (Array.isArray(items)) {
		for (let i = 0; i < items.length; ++i) {
			--items[i].data.refCount
		}
	} else {
		--items.data.refCount
	}
}
function removeItemOnce(arr, value) {
	let index = arr.indexOf(value);
	if (index > -1) {
		arr.splice(index, 1);
	}
	return index;
}
function getSeconds(value, defaultVal) {
	if (typeof value == 'string' || value instanceof String) {
		let tokens = value.split(':')
		if (tokens.length != 3) {
			return defaultVal
		}
		let hours = Number(tokens[0])
		let minutes = Number(tokens[1])
		let seconds = Number(tokens[2])
		return hours * 3600 + minutes * 60 + seconds
	}
	return defaultVal
}
let interval = null
function common_pauseVideo(refresh = true) {
	playButton.innerText = '\u25b6'
	if (playerLoaded) {
		player.pauseVideo()
		}
	if (popupWnd) {
		popupWnd.close()
		popupWnd = null
	}
	if (interval) {
		clearInterval(interval)
		interval = null
	}
	if (refresh) {
		refreshControlPanel()
}
}
function common_stopVideo(refresh = true) {
	for (let i = 0; i < playContextStack.length; ++i) {
		playContextStack[i].currentPlayingItem = undefined
	}
	array_clear(playContextStack)
	currentVideoClip = null
	if (playerLoaded) {
		player.stopVideo()
	}
	common_pauseVideo(refresh)
}
var ReservedVolume = undefined;
function player_getVolume() {
	return ReservedVolume != undefined
	? ReservedVolume
	: playerLoaded
		? player.getVolume()
		: 100
}
function getLink(value) {
	let start = getSeconds(value.start, 0)
	//*/
	let url = ["https://www.youtube.com/watch?v=", value.ID]
	if (start > 0) {
		url.push("&t=", start)
	}
	/*/
	let url = ["https://www.youtube.com/embed/", value.ID, "?autoplay=1"]
	if (start > 0) {
		url.push("&start=", start)
	}
	let endtime = getSeconds(value.end, 0)
	if (endtime > 0) {
		url.push("&end=", endtime)
	}
	//*/
	return url.join('')
}
function openWindow(value) {
	let url = getLink(value)
	
	let viewportOffset = divPlayer.getBoundingClientRect()
	return window.open(url, '_blank', 'width=' + videoWidth + ',height=' + videoHeight + ',top=' + (viewportOffset.top + 108) + ',left=' +viewportOffset.left)
}
function tempAlert(msg,duration) {
	let el = document.createElement("div");
	el.setAttribute("style","position:absolute;top:40%;left:20%;width:300;height:100;background-color:yellow;text-align:center;");
	el.innerHTML = "<h3>" + msg + "</h3>"
	setTimeout(function(){
		el.parentNode.removeChild(el);
	},duration);
	document.body.appendChild(el);
}
function player_getPlayerState() {
	return playerLoaded ? player.getPlayerState() : YT.PlayerState.ENDED
}
function refreshPlayButton() {
	if (popupWnd) {
		if (!playButton.wnd) {
			playButton.wnd = true
			playButton.innerHTML = '\u23f9'
			playButton.title = 'Stop'
		}
	} else {
		let state = player_getPlayerState()
		if (playButton.state != state) {
			playButton.state = state
			if (state == YT.PlayerState.PLAYING) {
				playButton.innerHTML = '\u23f8'
				playButton.title = 'Pause'
			} else {
				playButton.innerText = '\u25b6'
				playButton.title = 'Play'
			}
			playButton.wnd = false
		}
	}
}
function playListItemsTable_selectAll() {
	playListItemsTable.selectAll()
}
function playListItemsTable_clearAll() {
	playListItemsTable.clearSelection()
}
function playListItemsTable_play(dataKey) {
	let dataIndex = playListItemsTable.getDataIndexByKey(dataKey)
	//console.log(dataKey, dataIndex)
	if (dataIndex == -1) {
		common_stopVideo()
		return
	}

	const playItem = playListItemsTable.getData(dataIndex)
	playListItems_play(playItem)
}
function playList_getItem(playList, key) {
	for (let i = 0; i < playList.items.length; ++i) {
		const item = playList.items[i]
		if (item.key == key) {
			return item
		}
	}
	return null
}
function playContext_copyFromView() {
	playContextStack = viewContextStack.slice()
	for (let i = 0; i < playContextStack.length; ++i) {
		playContextStack[i].currentPlayingItem = playContextStack[i].currentViewingItem
	}
}
function playContext_copyFromPlay() {
	viewContextStack = playContextStack.slice()
	for (let i = 0; i < viewContextStack.length; ++i) {
		viewContextStack[i].currentViewingItem = viewContextStack[i].currentPlayingItem
	}
}
function playListItems_play(playItem) {
	const playList = playItem.playList
	const ctx = playContext_get(playList)
	const data = playList.data
	
	playContext_copyFromView()
	ctx.currentPlayingItem = playItem
	playContext_play_r(ctx)
}
function playContext_getCurrentPlayKey(ctx) {
	if (ctx.currentPlayingItem == undefined) {
		ctx.currentPlayingItem = ctx.playOrder[0]
	}
	return ctx.currentPlayingItem.key
}
function playContext_getCurrentViewKey(ctx) {
	if (ctx.currentViewingItem == undefined) {
		ctx.currentViewingItem = ctx.playOrder[0]
	}
	return ctx.currentViewingItem.key
}
function playContext_play_r(ctx) {
	const key = playContext_getCurrentPlayKey(ctx)
	const data = playList_getItem(ctx.data, key).data
	if (data.type == 1) {
		playVideoData(data)
	} else if (data.type == 2) {
		const ctx = playContext_get(data)
		if (playContextStack.indexOf(ctx) != -1) {
			return false
		}
		if (ctx.playOrder.length == 0) {
			return false
		}
		playContextStack.push(ctx)
		return playContext_play_r(ctx)
	}
	return true
}
function playListItemsTable_playOrOpen(dataKey, doPlay) {
	let dataIndex = playListItemsTable.getDataIndexByKey(dataKey)
	//console.log(dataKey, dataIndex)
	if (dataIndex == -1) {
		return
	}

	const playItem = playListItemsTable.getData(dataIndex)				
	const playList = playItem.playList
	const ctx = playContext_get(playList)
	const data = playList.data
	
	if (viewContextStack.length) {
		let lastCtx = viewContextStack[viewContextStack.length - 1]
		if (ctx != lastCtx) {
			return
		}
	} else {
		return
	}
	ctx.currentViewingItem = playItem
	playContext_playOrOpen_r(ctx, doPlay)
}
function playContext_playOrOpen_r(ctx, doPlay) {
	const key = playContext_getCurrentViewKey(ctx)
	const data = playList_getItem(ctx.data, key).data
	if (data.type == 1) {
		if (doPlay) {
			playContext_copyFromView()
			playVideoData(data)
		}
	} else if (data.type == 2) {
		const ctx = playContext_get(data)
		if (viewContextStack.indexOf(ctx) != -1) {
			return false
		}
		playList_push(data)
		return true
	}
	return true
}

let ReservedStartTime = undefined;
let LastVideoTime = 0
let playCounter = 0
function playVideoData(data) {
	if (!data) {
		common_stopVideo()
		return
	}
	
	if (popupWnd) {
		popupWnd.close()
		popupWnd = null
	}
	if (interval) {
		clearInterval(interval)
		interval = null
	}
	
	let volume = Number(volumeControl.value)
	//console.log('volumeControl:' + volume)
	let relVolume = individualVolumeMap.get(data.key)
	if (relVolume != undefined) {
		volume += relVolume
	}
	if (player_getVolume() != volume) {
		//console.log('setVolume:' + volume + ';relVolume:' + relVolume)
		player.setVolume(volume)
	}
	
	currentVideoClip = data
	let beginTime = Date.now()
	console.log('[' + beginTime + ']playVideoData: ' + currentVideoClip.key)
	let startTime = getSeconds(data.start, 0)
	let endtime = getSeconds(data.end, -1)
	let playingKey = ++playCounter
	
	if (!data.restricted) {
		playVideo(data.ID, startTime, endtime, volume)
		videoControl.min = startTime
		if (endtime != -1) {
			videoControl.max = endtime
		} else {
			videoControl.max = startTime + 10
		}
		videoControl.value = 0
	} else {
		player.stopVideo()
		popupWnd = openWindow(data)
		if (popupWnd == null) {
			onFinishVideo(false)
			return
		}
		videoControl.min = startTime
		if (endtime != -1) {
			videoControl.max = endtime + 10
		} else {
			videoControl.max = startTime + 10
		}
		videoControl.value = 0
	}
	refreshControlPanel()
	playListTable.updateList()
	playListItemsTable.updateList()

	interval = setInterval(function() {
		if (popupWnd) {
			let curTime = Date.now()
			if (endtime >= 0) {
				let restMilliseconds = (beginTime + (endtime - startTime + 10) * 1000) - curTime
				if (restMilliseconds <= 0 && !popupWnd.closed && playingKey == playCounter) {
					onFinishVideo(false)
				}
				let value = (curTime - beginTime) / 1000 + startTime
				videoControl.value = value
			}
			if ((curTime - beginTime) > 5000 && popupWnd && popupWnd.closed && playingKey == playCounter) {
				onFinishVideo(false)
			}
		} else {
			let state = player_getPlayerState()
			if (endtime == -1 && state == YT.PlayerState.PLAYING)
			{
				endtime = player.getDuration()
				videoControl.max = endtime
			}
			if (state == YT.PlayerState.PLAYING || state == YT.PlayerState.PAUSED)
			{
				if (!videoControl.isChanging) {
					let currenTime = player.getCurrentTime()
					videoControl.value = currenTime
					if (ReservedStartTime != undefined)
					{
						let diff = Math.abs(currenTime - ReservedStartTime);
						if (diff > 1)
						{
							player.seekTo(ReservedStartTime, true);
						}
						else
						{
							//console.log('OnInterval.setVolume' + ';currenTime:' + currenTime)
							player.setVolume(ReservedVolume)
							ReservedStartTime = undefined
							LastVideoTime = currenTime
						}
					}
					else
					{
						let diff = Math.abs(LastVideoTime - currenTime)
						if (diff > 1.5 && (curTime - beginTime) <= 10000)
						{
							player.seekTo(LastVideoTime, true);
						}
						else if (endtime < currenTime)
						{
							//console.log('OnInterval.FinishVideo' + ';currenTime:' + currenTime + ';endtime:' + endtime)
							console.log('OnInterval.FinishVideo: ' + currentVideoClip.key)
							onFinishVideo(false)
						}
						else
						{
							LastVideoTime = currenTime;
						}
					}
				}
				if (!volumeControl.isChanging) {
					if (ReservedStartTime == undefined)
					{
						let CurrentVolume = player.getVolume();
						if (ReservedVolume == undefined)
						{
							volumeControl_update(CurrentVolume)
						}
						else if (ReservedVolume != CurrentVolume)
						{
							player.setVolume(ReservedVolume)
						}
						else
						{
							ReservedVolume = undefined;
						}
					}
				}
			}
		}
		refreshPlayButton()
	}, 100)
	
	/*
	let url = ["https://www.youtube.com/embed/", value.ID, "?start=", getSeconds(value.start, 0), "&autoplay=1"]
	let endtime = getSeconds(value.end, -1)
	if (endtime >= 0) {
		url.push("&end=", endtime)
	}
	url = url.join('')
	
	alert(url)
	let frame = document.createElement("iframe")
	frame.src = url
	frame.allow = "autoplay"
	frame.width = "1280"
	frame.height = "720"
	
	let div = document.getElementById("Frame")
	div.innerHTML = ""
	document.getElementById("Frame").appendChild(frame)
	*/
}
function totalList_playVideo(selectedIndex) {
	if (selectedIndex < 0 || videoClipTable.length <= selectedIndex) {
		common_stopVideo()
		return
	}
	
	common_stopVideo(false)
	let value = videoClipTable.getData(selectedIndex)
	playVideoData(value)
}
function totalList_selectAll() {
	videoClipTable.selectAll()
}
function totalList_clearAll() {
	videoClipTable.clearSelection()
}
function totalList_modify() {
	let keys = videoClipTable.selectedDataKeys
	if (keys.length > 0) {
		modifyVideoClipDialog_IndividualVolume.value = '0'
		modifyVideoClipDialog.onclose = function() {
			if (modifyVideoClipDialog.returnValue == 'ok') {
				let volume = Number(modifyVideoClipDialog_IndividualVolume.value)
				if (volume == 0) {
					for (let i = 0; i < keys.length; ++i) {
						individualVolumeMap.delete(keys[i])
					}
				} else {
					for (let i = 0; i < keys.length; ++i) {
						individualVolumeMap.set(keys[i], volume)
					}
				}
				videoClipTable.updateList()
				volume_save()
			}
		}
		if (typeof modifyVideoClipDialog.showModal === "function") {
			modifyVideoClipDialog.showModal();
		} else {
			alert("The <dialog> API is not supported by this browser");
		}
	}
}
function onYouTubeIframeAPIReady() {
	player = new YT.Player('player', {
		height: videoHeight,
		width: videoWidth,
		videoId: '',
		events: {
			'onReady': onPlayerReady,
			'onStateChange': onPlayerStateChange,
			'onError' : onError,
		}
	})
}
function onPlayerReady(event) {
	playerLoaded = true
	volumeControl_update(player_getVolume())
	refreshControlPanel()
}
function onPlayerStateChange(event) {
	//console.log(event.data)
	if (event.data === YT.PlayerState.ENDED){
		onFinishVideo(false)
	}
}
function onError(event) {
	console.log(event)
}
function playVideo(id, start, end, volume) {
	if (end < 0) {
		player.loadVideoById({
				'videoId': id,
				'startSeconds': start,
		});
	} else {
		player.loadVideoById({
			'videoId': id,
			'startSeconds': start,
			'endSeconds': end,
		});
	}
	ReservedStartTime = start
	ReservedVolume = volume
	if (ReservedVolume < 0)
	{
		ReservedVolume = 0;
	}
	player.setVolume(0)
}
let LastExecFinishVideoTime = 0;
function onFinishVideo(bForce) {
	let CurTime = Date.now()
	if (bForce || CurTime - LastExecFinishVideoTime > 1000)
	{
		LastExecFinishVideoTime = CurTime
		playListItems_next(true)
	}
}
function shuffle(array, start, end) {
	start = isUndefined(start, 0)
	end = isUndefined(end, array.length)
	for (let index = end - 1; index > start; index--) {
		const randomPosition = Math.floor(Math.random() * (index - start + 1) + start)
		const temporary = array[index]
		array[index] = array[randomPosition]
		array[randomPosition] = temporary
	}
}
function updatePlayerOrder() {
	const playOrder = currentViewContext.playOrder
	const playOrderMap = currentViewContext.playOrderMap
	const newPlayOrder = []
	for (let i = 0; i < playOrder.length; ++i) {
		if (playListItemsTable.getDataByKey(playOrder[i].key)) {
			newPlayOrder.push(playOrder[i])
		}
	}
	currentViewContext.playOrder = newPlayOrder
	playContext_refreshPlayerOrderMap(currentViewContext)
}
function playContext_refreshPlayerOrderMap(playContext) {
	const playOrder = playContext.playOrder
	const playOrderMap = playContext.playOrderMap
	playOrderMap.clear()
	for (let i = 0; i < playOrder.length; ++i) {
		playOrderMap.set(playOrder[i].key, i)
	}
}
function playContext_shuffleByPriority(playOrder) {
	if (playOrder.length <= 0) {
		return
	}
	playOrder.sort(function(a,b) {
		a = a.shufflePriority
		b = b.shufflePriority
		return a < b ? 1 : a > b ? -1 : 0
	})
	let prevPriority = playOrder[0].shufflePriority
	let startIndex = 0
	for (let i = 1; i < playOrder.length; ++i) {
		const currentPriority = playOrder[i].shufflePriority
		if (currentPriority != prevPriority) {
			shuffle(playOrder, startIndex, i)
			prevPriority = currentPriority
			startIndex = i
		}
	}

	if (startIndex < playOrder.length) {
		shuffle(playOrder, startIndex, playOrder.length)
	}
}
function playContext_shufflePlayOrder(playContext) {
	const playOrder = playContext.playOrder
	const playOrderMap = playContext.playOrderMap
	const currentPlayingItem = playContext.currentPlayingItem
	if (currentPlayingItem) {
		let orderIdx = playOrderMap.get(currentPlayingItem.key)
		playOrder.splice(orderIdx, 1)
		playContext_shuffleByPriority(playOrder)
		playOrder.unshift(currentPlayingItem)
	} else {
		playContext_shuffleByPriority(playOrder)
	}
	playContext_refreshPlayerOrderMap(playContext)
}
function playContext_resetPlayOrder(playContext) {
	const playOrder = playContext.playOrder
	const playOrderMap = playContext.playOrderMap
	array_clear(playOrder)
	const items = playContext.data.items;
	for (let i = 0; i < items.length; ++i) {
		playOrder.push(items[i])
	}
	playContext_refreshPlayerOrderMap(playContext)
}
function playList_shufflePlayOrder() {
	playContext_shufflePlayOrder(currentViewContext)
	playListItemsTable.updateList()
}
function playList_resetPlayOrder() {
	playContext_resetPlayOrder(currentViewContext)
	playListItemsTable.updateList()
	}
function playList_shuffle() {
	const sufflePlayList = currentViewContext ? currentViewContext.shuffled : false
	if (sufflePlayList) {
		playList_shufflePlayOrder()
	} else {
		playList_resetPlayOrder()
	}
}
function playList_onKeyDown() {
	if (event.keyCode == 46) {
		playListItemsTable_deleteSelected()
	} else {
		list_onKeyDown(playListItemsTable)
	}
}
function playListItemsTable_deleteSelected() {
	let selectedDataKeys = playListItemsTable.selectedDataKeys
	if (selectedDataKeys.length == 0) {
		return
	}
	playListItemsTable.beginUpdate()
	let items = playListItemsTable.deleteSelection()
	playList_itemsDeleted(items)
	updatePlayerOrder()
	playListItemsTable.endUpdate()
	playListTable.updateList()
	videoClipTable.updateList()
	
	for (let i = 0; i < playContextStack.length; ++i) {
		const ctx = playContextStack[i]
		if (ctx.currentPlayingItem && ctx.playOrderMap.get(ctx.currentPlayingItem.key) == undefined) {
			common_stopVideo()
			break
		}
	}
	playListItemsTable.focus()
	setDataChanged()
}
function playListItemsTable_deleteAll() {
	if (playContextStack.length != 0) {
		common_stopVideo(false)
	}
	currentViewContext.playOrder = []
	currentViewContext.playOrderMap.clear()
	playList_itemsDeleted(currentViewContext.data.items)
	array_clear(currentViewContext.data.items)
	videoClipTable.updateList()
	playListItemsTable.refreshList()
	playListItemsTable.focus()
	refreshControlPanel()
	setDataChanged()
}
function updateDivVisible() {
	divTotallist.style.display = showTotallist.checked ? 'flex' : 'none'
	divPlaylistPanel.style.display = showPlaylist.checked ? 'flex' : 'none'
	divPlaylistItemsPanel.style.display = showPlaylistItems.checked ? 'flex' : 'none'
	divClipSpreadSheet.style.display = showClipTableURL.checked ? 'flex' : 'none'
	//playListItemsTable.adjustScroll()
}
function playList_getJson() {
	let playListSaveData = []				
	let playListData = playListTable.dataList
	for (let i = 0; i < playListData.length; ++i) {
		const data = playListData[i]
		const items = []
		for (let j = 0; j < data.items.length; ++j) {
			let item = data.items[j]
			let itemData = { key:item.data.key }
			if (item.shufflePriority != 0) {
				itemData.shufflePriority = item.shufflePriority
			}
			items.push(itemData)
		}
		playListSaveData.push({ key:data.key, category:data.category, date:data.date, trackName:data.trackName, originalArtist:data.originalArtist, coveredBy:data.coveredBy, items:items, shuffle:data.shuffle, entirePlay:data.entirePlay })
	}
	return playListSaveData
}
function volume_getJson() {
	let individualVolumeList = []
	for (let val of individualVolumeMap) {
		if (val[1] != 0) {
			individualVolumeList.push(val)
		}
	}

	return individualVolumeList
}
function playList_save() {
	localStorage.setItem("watamePlayer_PlayList", JSON.stringify(playList_getJson()))
	dataChanged = false
}
function volume_save() {
	localStorage.setItem("watamePlayer_Volumes", JSON.stringify(volume_getJson()))
	dataChanged = false
}
function playList_newPanel() {
	playListDialog_Category.value = ''
	playListDialog_Date.value = date_today()
	playListDialog_TrackName.value = ''
	playListDialog_OriginalArtist.value = ''
	playListDialog_CoveredBy.value = ''
	playListDialog_cbShuffle.checked = false
	playListDialog_cbPlayEntireVideo.checked = false
	playListDialog.onclose = function() {
		if (playListDialog.returnValue == 'ok') {
			let playList = playList_new()
			playList.category = playListDialog_Category.value
			playList.date = playListDialog_Date.value
			playList.trackName = playListDialog_TrackName.value
			playList.originalArtist = playListDialog_OriginalArtist.value
			playList.coveredBy = playListDialog_CoveredBy.value
			playList.shuffle = playListDialog_cbShuffle.checked
			playList.entirePlay = playListDialog_cbPlayEntireVideo.checked
			makeSearchText(playList)
			playListTable.insertData(playList)
			playListTable.selectedDataKey = playList.key
			setDataChanged()
	}
	}
	if (typeof playListDialog.showModal === "function") {
		playListDialog.showModal();
	} else {
		alert("The <dialog> API is not supported by this browser");
	}
}
function playList_editPanel() {
	let data = playListTable.selectedData
	if (data) {
		playListDialog_Category.value = isUndefined(data.category, '')
		playListDialog_Date.value = isUndefined(data.date, '')
		playListDialog_TrackName.value = isUndefined(data.trackName, '')
		playListDialog_OriginalArtist.value = isUndefined(data.originalArtist, '')
		playListDialog_CoveredBy.value = isUndefined(data.coveredBy, '')
		playListDialog_cbShuffle.checked = isUndefined(data.shuffle, false)
		playListDialog_cbPlayEntireVideo.checked = isUndefined(data.entirePlay, false)
		playListDialog.onclose = function() {
			if (playListDialog.returnValue == 'ok') {
				data.category = playListDialog_Category.value
				data.date = playListDialog_Date.value
				data.trackName = playListDialog_TrackName.value
				data.originalArtist = playListDialog_OriginalArtist.value
				data.coveredBy = playListDialog_CoveredBy.value
				data.shuffle = playListDialog_cbShuffle.checked
				data.entirePlay = playListDialog_cbPlayEntireVideo.checked
				makeSearchText(data)
				playListTable.updateList()
				playListItemsTable.updateList()
				setDataChanged()
				playList_updateCheckboxes()
			}
		}
		if (typeof playListDialog.showModal === "function") {
			playListDialog.showModal();
		} else {
			alert("The <dialog> API is not supported by this browser");
		}
	}
}
function playList_clonePanel() {
	let data = playListTable.selectedData
	if (data) {
		playListDialog_Category.value = isUndefined(data.category, '')
		playListDialog_Date.value = isUndefined(data.date, '')
		playListDialog_TrackName.value = isUndefined(data.trackName, '')
		playListDialog_OriginalArtist.value = isUndefined(data.originalArtist, '')
		playListDialog_CoveredBy.value = isUndefined(data.coveredBy, '')
		playListDialog_cbShuffle.checked = isUndefined(data.shuffle, false)
		playListDialog_cbPlayEntireVideo.checked = isUndefined(data.entirePlay, false)
		playListDialog.onclose = function() {
			if (playListDialog.returnValue == 'ok') {
				let playList = playList_new()
				playList.category = playListDialog_Category.value
				playList.date = playListDialog_Date.value
				playList.trackName = playListDialog_TrackName.value
				playList.originalArtist = playListDialog_OriginalArtist.value
				playList.coveredBy = playListDialog_CoveredBy.value
				playList.shuffle = playListDialog_cbShuffle.checked
				playList.entirePlay = playListDialog_cbPlayEntireVideo.checked
				playList.items = data.items.slice()
				makeSearchText(playList)
				playListTable.insertData(playList)
				playListTable.selectedDataKey = playList.key
				setDataChanged()
			}
		}
		if (typeof playListDialog.showModal === "function") {
			playListDialog.showModal();
		} else {
			alert("The <dialog> API is not supported by this browser");
		}
	}
}
function isBoolean(val) {
   return val === false || val === true;
}
function Select_getBool(e) {
	let index = Number(e.selectedIndex)
	let value = e.options[index].value
	if (value.length == 0) {
		return null
	}
	let intValue = Number(value)
	return intValue != 0
}
function playListTable_modify() {
	let keys = playListTable.selectedDataKeys
	if (keys.length > 0) {
		modifyPlayListDialog_Shuffle.selectedIndex = 0
		modifyPlayListDialog_PlayEntireVideo.selectedIndex = 0
		modifyPlayListDialog.onclose = function() {
			if (modifyPlayListDialog.returnValue == 'ok') {
				let bShuffle = Select_getBool(modifyPlayListDialog_Shuffle)
				let bPlayEntireVideo = Select_getBool(modifyPlayListDialog_PlayEntireVideo)
				let bIsShuffleBool = isBoolean(bShuffle)
				let bIsPlayEntireVideoBool = isBoolean(bPlayEntireVideo)
				if (bIsShuffleBool || bIsPlayEntireVideoBool) {
					for (let i = 0; i < keys.length; ++i) {
						let data = playListTable.getDataByKey(keys[i])
						if (bIsShuffleBool) {
							data.shuffle = bShuffle
						}
						if (bIsPlayEntireVideoBool) {
							data.entirePlay = bPlayEntireVideo
						}
					}
					playListTable.updateList()
					setDataChanged()
					playList_updateCheckboxes()
				}
			}
		}
		if (typeof modifyPlayListDialog.showModal === "function") {
			modifyPlayListDialog.showModal();
		} else {
			alert("The <dialog> API is not supported by this browser");
		}
	}
}
function totalList_addToPlaylist(selected) {
	let keys = selected ? videoClipTable.selectedDataKeys.slice() : videoClipTable.copyDataOrder()
	if (keys.length == 0) {
		return
	}
	let itmeKeys = []
	playListItemsTable.beginUpdate()
	for (let i = 0; i < keys.length; ++i) {
		let data = videoClipTable.getDataByKey(keys[i])
		let item = playList_insertItem(null, data)
		itmeKeys.push(item.key)
	}
	playListItemsTable.endUpdate()
	videoClipTable.updateList()
	playListItemsTable.clearSelection()
	for (let i = 0; i < itmeKeys.length; ++i) {
		playListItemsTable.setDataRowSelection(itmeKeys[i], true)
	}
	setDataChanged()
}
function playList_addToPlayListItemsByKeys(keys) {
	let itmeKeys = []
	playListItemsTable.beginUpdate()
	for (let i = 0; i < keys.length; ++i) {
		let data = playListTable.getDataByKey(keys[i])
		let item = playList_insertItem(null, data)
		itmeKeys.push(item.key)
	}
	playListItemsTable.endUpdate()
	playListTable.updateList()
	playListItemsTable.clearSelection()
	for (let i = 0; i < itmeKeys.length; ++i) {
		playListItemsTable.setDataRowSelection(itmeKeys[i], true)
	}
	setDataChanged()
}
function playList_addToPlayListItems() {
	let dataOrder = playListTable.copyDataOrder()
	playList_addToPlayListItemsByKeys(dataOrder)
}
function playList_addSelectedToPlayListItems() {
	let selectedDataKeys = playListTable.selectedDataKeys.slice()
	if (selectedDataKeys.length == 0) {
		return
	}
	playList_addToPlayListItemsByKeys(selectedDataKeys)
}
function fillCharacter(text, len, ch) {
	text = text.toString()
	if (text.length >= len) {
		return text
	}
	return ch.repeat(len - text.length) + text
}
function date_today() {
	const today = new Date()
	const year = today.getFullYear()
	const month = today.getMonth() + 1
	const date = today.getDate()
	return `${year}-${fillCharacter(month, 2, '0')}-${fillCharacter(date, 2, '0')}`
}
function totalList_makePlayListPanel(selectedClip) {
	let keys = selectedClip ? videoClipTable.selectedDataKeys.slice() : videoClipTable.copyDataOrder()
	if (keys.length == 0) {
		return
	}
	playListDialog_Category.value = ''
	playListDialog_Date.value = date_today()
	playListDialog_TrackName.value = ''
	playListDialog_OriginalArtist.value = ''
	playListDialog_CoveredBy.value = ''
	playListDialog_cbShuffle.checked = false
	playListDialog_cbPlayEntireVideo.checked = false

	const commonCategory = 'Various Category'
	const commonTrackName = 'Various Track'
	const commonOriginalArtist = 'Various Artist'
	const commonCoveredBy = 'Various Artist'

	let items = videoClipTable.getDataByKey(keys)
	for (let i = 0; i < items.length; ++i) {
		const item = items[i]
		playListDialog_Category.value = totalList_selectRepresentText(playListDialog_Category.value, item.category, commonCategory)
		playListDialog_TrackName.value = totalList_selectRepresentText(playListDialog_TrackName.value, item.trackName, commonTrackName)
		playListDialog_OriginalArtist.value = totalList_selectRepresentText(playListDialog_OriginalArtist.value, item.originalArtist, commonOriginalArtist)
		playListDialog_CoveredBy.value = totalList_selectRepresentText(playListDialog_CoveredBy.value, item.coveredBy, commonCoveredBy)
	}

	playListDialog.onclose = function() {
		if (playListDialog.returnValue == 'ok') {
			let playList = playList_new()
			playList.category = playListDialog_Category.value
			playList.date = playListDialog_Date.value
			playList.trackName = playListDialog_TrackName.value
			playList.originalArtist = playListDialog_OriginalArtist.value
			playList.coveredBy = playListDialog_CoveredBy.value
			playList.shuffle = playListDialog_cbShuffle.checked;
			playList.entirePlay = playListDialog_cbPlayEntireVideo.checked;

			for (let i = 0; i < keys.length; ++i) {
				let data = videoClipTable.getDataByKey(keys[i])
				playList_insertItem(playList, data)
			}

			makeSearchText(playList)
			playListTable.insertData(playList)
			playListTable.selectedDataKey = playList.key
			videoClipTable.updateList()
			setDataChanged()
		}
	}
	if (typeof playListDialog.showModal === "function") {
		playListDialog.showModal();
	} else {
		alert("The <dialog> API is not supported by this browser");
	}
}
function totalList_makeGroupedPlayListPanel(selectedClip) {
	totalListHeaderSelect_cbCategory.checked = true
	totalListHeaderSelect_cbDate.checked = true
	totalListHeaderSelect_cbTitle.checked = true
	totalListHeaderSelect_cbOriSinger.checked = true
	totalListHeaderSelect_cbSinger.checked = true
	totalListHeaderSelect_cbShuffle.checked = true
	totalListHeaderSelect_cbPlayEntireVideo.checked = false
	totalListHeaderSelect_cbAppendIfExists.checked = false
	totalListHeaderSelect_cbAppendToFront.checked = true
	totalListHeaderSelect_cbAppendToFront.disabled = true
	totalListHeaderSelect_CommonCategory.value = "Various Category"
	totalListHeaderSelect_CommonTrackName.value = "Various Track"
	totalListHeaderSelect_CommonOriginalArtist.value = "Various Artist"
	totalListHeaderSelect_CommonCoveredBy.value = "Various Artist"
	totalListHeaderSelectDialog.onclose = function() {
		if (totalListHeaderSelectDialog.returnValue == 'ok') {
			const headerNames = []
			if (totalListHeaderSelect_cbCategory.checked) {
				headerNames.push('category')
			}
			if (totalListHeaderSelect_cbDate.checked) {
				headerNames.push('date')
			}
			if (totalListHeaderSelect_cbTitle.checked) {
				headerNames.push('trackName')
			}
			if (totalListHeaderSelect_cbOriSinger.checked) {
				headerNames.push('originalArtist')
			}
			if (totalListHeaderSelect_cbSinger.checked) {
				headerNames.push('coveredBy')
			}
			
			if (headerNames.length == 0) {
				return
			}
			const headers = videoClipTable.selectHeader(headerNames)
			if (headers.length == 0) {
				return
			}
			const shuffle = totalListHeaderSelect_cbShuffle.checked
			const playEntireVideo = totalListHeaderSelect_cbPlayEntireVideo.checked
			const commonCategory = totalListHeaderSelect_CommonCategory.value
			const commonTrackName = totalListHeaderSelect_CommonTrackName.value
			const commonOriginalArtist = totalListHeaderSelect_CommonOriginalArtist.value
			const commonCoveredBy = totalListHeaderSelect_CommonCoveredBy.value
			let option = {
				selectedClip : selectedClip,
				shuffle : shuffle,
				playEntireVideo : playEntireVideo,
				appendIfExists : totalListHeaderSelect_cbAppendIfExists.checked,
				appendtoFront : totalListHeaderSelect_cbAppendToFront.checked,
				commonTextMap : { category:commonCategory, trackName:commonTrackName, originalArtist:commonOriginalArtist, coveredBy:commonCoveredBy },
			}
			const playListData = totalList_makeGroupedPlayList(headers, option)
			if (playListData.length) {
				playListTable.clearSelection()
				playListTable.insertDataList(playListData)
				for (let i = 0; i < playListData.length; ++i) {
					playListTable.setDataRowSelection(playListData[i].key, true)
				}
				playListTable.scrollToRowByDataKey(playListData[0].key, true)
			} else {
				playListTable.updateList()
			}
			videoClipTable.updateList()
			setDataChanged()
		}
	}
	if (typeof totalListHeaderSelectDialog.showModal === "function") {
		totalListHeaderSelectDialog.showModal();
	} else {
		alert("The <dialog> API is not supported by this browser");
	}
}
function totalList_selectRepresentText(a, b, def) {
	if (a == b) {
		return a
	}
	if (a == null || a == '') {
		return b
	}
	return def
}
function totalList_selectRepresentDate(a, b) {
	if (a == null) {
		return b
	}
	if (a < b) {
		return b
	}
	return a
}
function dataList_groupBy(dataList, headers) {
	let groupMap = new Map()
	for (let i = 0; i < dataList.length; ++i) {
		let data = dataList[i]
		let key = ''
		for (let j = 0; j < headers.length; ++j) {
			if (j != 0) {
				key += '|'
			}
			key += header_getData(headers[j], data)
		}
		let items = groupMap.get(key)
		if (!items) {
			items = []
			groupMap.set(key, items)
		}
		items.push(data)
	}
	return groupMap
}
function totalList_makeGroupedPlayList(headers, options) {
	let dataList = []
	let dataOrder = options.selectedClip ? videoClipTable.selectedDataKeys : videoClipTable.copyDataOrder()
	for (let i = 0; i < dataOrder.length; ++i) {
		dataList.push(videoClipTable.getDataByKey(dataOrder[i]))
	}
	return makeGroupedPlayListByDataList(dataList, headers, options)
}
function makeGroupedPlayListByDataList(dataList, headers, options) {
	let dataGroup = dataList_groupBy(dataList, headers)
	let playListGroup = dataList_groupBy(playListTable.dataList, headers)
	
	let playListItems = []
	const shuffle = options.shuffle
	const playEntireVideo = options.playEntireVideo
	const appendIfExists = options.appendIfExists
	const appendtoFront = options.appendtoFront
	const commonTextMap = options.commonTextMap
	let commonCategory = isUndefined(commonTextMap.category, 'Various Category')
	let commonTrackName = isUndefined(commonTextMap.trackName, 'Various Track')
	let commonOriginalArtist = isUndefined(commonTextMap.originalArtist, 'Various Artist')
	let commonCoveredBy = isUndefined(commonTextMap.coveredBy, 'Various Artist')
	for (let kv of dataGroup) {
		let key = kv[0]
		let items = kv[1]
		
		if (appendIfExists) {
			let playLists = playListGroup.get(key)
			if (playLists) {
				for (let i = 0; i < playLists.length; ++i) {
					let playList = playLists[i]
					playList_insertItems(playList, items, null, appendtoFront)
					for (let i = 0; i < items.length; ++i) {
						const item = items[i]
						playList.date = totalList_selectRepresentDate(playList.date, item.date)
					}
				}
				continue
			}
		}

		let subplayList = playList_new()
		subplayList.category = null
		subplayList.trackName = null
		subplayList.originalArtist = null
		subplayList.coveredBy = null
		subplayList.date = null
		subplayList.shuffle = shuffle
		subplayList.entirePlay = playEntireVideo
		for (let i = 0; i < items.length; ++i) {
			const item = items[i]
			playList_newItem(subplayList, item, 0)
			subplayList.category = totalList_selectRepresentText(subplayList.category, item.category, commonCategory)
			subplayList.trackName = totalList_selectRepresentText(subplayList.trackName, item.trackName, commonTrackName)
			subplayList.originalArtist = totalList_selectRepresentText(subplayList.originalArtist, item.originalArtist, commonOriginalArtist)
			subplayList.coveredBy = totalList_selectRepresentText(subplayList.coveredBy, item.coveredBy, commonCoveredBy)
			subplayList.date = totalList_selectRepresentDate(subplayList.date, item.date)
		}
		makeSearchText(subplayList)
		playListItems.push(subplayList)
	}
	return playListItems
}
function playButton_onClick() {
	if (popupWnd) {
		common_pauseVideo()
		return
	}
	const currentPlayingItem = currentViewContext.currentPlayingItem
	const playOrder = currentViewContext.playOrder
	let state = player_getPlayerState()
	if (state == YT.PlayerState.PLAYING || state == YT.PlayerState.BUFFERING) {
		player.pauseVideo()
	} else if (state == YT.PlayerState.PAUSED) {
		player.playVideo()
	} else if (currentPlayingItem != undefined) {
		playListItemsTable_play(currentPlayingItem.key)
	} else if (playListItemsTable.selectedDataKey != undefined) {
		playListItemsTable_play(playListItemsTable.selectedDataKey)
	} else if (playOrder.length > 0) {
		playListItemsTable_play(playOrder[0].key)
	}
}
function prevButton_onClick() {
	playListItems_prev()
}

function playListItems_prev() {
	const state = player_getPlayerState()
	if (state == YT.PlayerState.BUFFERING) {
		return
	}
	while (playContextStack.length != 0) {
		const isLast = playContextStack.length == 1
		var ctx = playContextStack[playContextStack.length - 1]
		const currentPlayingItem = ctx.currentPlayingItem
		if (!currentPlayingItem) {
			playContextStack.pop()
			continue
		}
		const playOrder = ctx.playOrder
		const playOrderMap = ctx.playOrderMap
		let orderIdx = playOrderMap.get(currentPlayingItem.key)
		if (orderIdx == undefined) {
			playContextStack.pop()
			continue
		}
		const playList = ctx.data
			--orderIdx
			if (orderIdx < 0) {
			ctx.currentPlayingItem = undefined
			if (isLast) {
				const sufflePlayList = ctx.shuffled
				if (sufflePlayList) {
					orderIdx = 0
				} else {
					orderIdx = playOrder.length - 1
				}
			} else {
				playContextStack.pop()
				continue
			}
		}
		ctx.currentPlayingItem = playOrder[orderIdx]
		if (!playList.entirePlay && !isLast) {
			playContextStack.pop()
			continue
		}
		if (playContext_play_r(ctx)) {
			break
		}
	}
}
function playListItems_next(videoFinished) {
	const state = player_getPlayerState()
	if (state == YT.PlayerState.BUFFERING) {
		return
	}
	if (playContextStack.length == 0)
	{
		player.stopVideo();
		return;
	}
	while (playContextStack.length != 0) {
		const isLast = playContextStack.length == 1
		var ctx = playContextStack[playContextStack.length - 1]
		const currentPlayingItem = ctx.currentPlayingItem
		if (!currentPlayingItem) {
			playContextStack.pop()
			continue
		}
		const playOrder = ctx.playOrder
		const playOrderMap = ctx.playOrderMap
		let orderIdx = playOrderMap.get(currentPlayingItem.key)
		if (orderIdx == undefined) {
			playContextStack.pop()
			continue
		}
		const playList = ctx.data
		if (videoFinished && modePlayList == PLAYMODE_REPEAT_ONE) {
		} else {
			++orderIdx
		}
		if (playOrder.length <= orderIdx) {
			ctx.currentPlayingItem = undefined
			if (!isLast) {
				if (videoFinished && ctx.shuffled) {
					playContext_shufflePlayOrder(ctx)
				}
				playContextStack.pop()
				continue
			} else if (videoFinished) {
				if (modePlayList == PLAYMODE_NORMAL) {
					playContextStack.pop()
					continue
			}
				if (ctx.shuffled) {
					playContext_shufflePlayOrder(ctx)
				}
			}
			orderIdx = 0
		}
		ctx.currentPlayingItem = playOrder[orderIdx]
		if (!playList.entirePlay && !isLast) {
			playContextStack.pop()
			continue
		}
		if (playContext_play_r(ctx)) {
			break
		}
	}
}
function nextButton_onClick() {
	playListItems_next(false)
}
function playListItemsTable_updatePlayOrder() {
	const sufflePlayList = currentViewContext ? currentViewContext.shuffled : false
	if (!sufflePlayList) {
		playList_resetPlayOrder()
	}
}
function playListItemsTable_moveToFront() {
	playListItemsTable.moveSelectionToFront()
	playListItemsTable.focus()
	playListItemsTable_updatePlayOrder()
	setDataChanged()
	}
function playListItemsTable_moveToBack() {
	playListItemsTable.moveSelectionToBack()
	playListItemsTable.focus()
	playListItemsTable_updatePlayOrder()
	setDataChanged()
}
function playListItemsTable_moveUp() {
	playListItemsTable.moveSelectedItemUp()
	playListItemsTable.focus()
	playListItemsTable_updatePlayOrder()
	setDataChanged()
	}
function playListItemsTable_moveDown() {
	playListItemsTable.moveSelectedItemDown()
	playListItemsTable.focus()
	playListItemsTable_updatePlayOrder()
	setDataChanged()
}
function playListItemsTable_modify() {
	let keys = playListItemsTable.selectedDataKeys
	if (keys.length > 0) {
		modifyPlayListDetailDialog_ShufflePriority.value = '0'
		modifyPlayListDetailDialog.onclose = function() {
			if (modifyPlayListDetailDialog.returnValue == 'ok') {
				let ShufflePriority = Number(modifyPlayListDetailDialog_ShufflePriority.value)
				for (let i = 0; i < keys.length; ++i) {
					let data = playListItemsTable.getDataByKey(keys[i])
					data.shufflePriority = ShufflePriority
				}
				playListItemsTable.updateList()
				setDataChanged()
			}
		}
		if (typeof modifyPlayListDetailDialog.showModal === "function") {
			modifyPlayListDetailDialog.showModal();
		} else {
			alert("The <dialog> API is not supported by this browser");
		}
	}
}
function totalList_Search() {
	let keyWord = searchTotallist.value
	if (keyWord == '') {
		videoClipTable.filterFunction = null
	} else {
		let dataOrder = []
		if (totalListSearchCaseInsensitive.checked) {
			keyWord = keyWord.toLowerCase()
			videoClipTable.filterFunction = function(data) {
				let searchTexts = data.searchLowerCaseTexts
				for (let j = 0; j < searchTexts.length; ++j) {
					if (searchTexts[j].indexOf(keyWord) != -1) {
						return true
					}
				}
				return false
			}
		} else {
			videoClipTable.filterFunction = function(data) {
				let searchTexts = data.searchTexts
				for (let j = 0; j < searchTexts.length; ++j) {
					if (searchTexts[j].indexOf(keyWord) != -1) {
						return true
					}
				}
				return false
			}
		}
	}
	videoClipTable.scrollToRowByDataKey(videoClipTable.selectedDataKey, true)
}
function playListTable_Search() {
	let keyWord = playListButton_search.value
	if (keyWord == '') {
		playListTable.filterFunction = null
	} else {
		if (playListSearchCaseInsensitive.checked) {
			keyWord = keyWord.toLowerCase()
			playListTable.filterFunction = function(data) {
				let searchTexts = data.searchLowerCaseTexts
				for (let j = 0; j < searchTexts.length; ++j) {
					if (searchTexts[j].indexOf(keyWord) != -1) {
						return true
					}
				}
				return false
			}
		} else {
			playListTable.filterFunction = function(data) {
				let searchTexts = data.searchTexts
				for (let j = 0; j < searchTexts.length; ++j) {
					if (searchTexts[j].indexOf(keyWord) != -1) {
						return true
					}
				}
				return false
			}
		}
	}
	playListTable.scrollToRowByDataKey(playListTable.selectedDataKey, true)
}
function playListTable_SearchByItemKey(searchItemKey) {
    if (!searchItemKey) {
        console.error("No itemKey ID provided");
        return;
    }

    playListTable.filterFunction = function(data) {
        for (let i = 0; i < data.items.length; i++) {
            let itemKey = data.items[i].data.key;
            if (itemKey === searchItemKey) {
                return true;
            }
        }
        return false;
    };

    playListTable.updateList();
}
function playListItemsTable_Search() {
	let keyWord = playListItemsButton_search.value
	if (keyWord == '') {
		playListItemsTable.filterFunction = null
	} else {
		if (playListItemsSearchCaseInsensitive.checked) {
			keyWord = keyWord.toLowerCase()
			playListItemsTable.filterFunction = function(data) {
				let searchTexts = data.data.searchLowerCaseTexts
				for (let j = 0; j < searchTexts.length; ++j) {
					if (searchTexts[j].indexOf(keyWord) != -1) {
						return true
					}
				}
				return false
			}
		} else {
			playListItemsTable.filterFunction = function(data) {
				let searchTexts = data.data.searchTexts
				for (let j = 0; j < searchTexts.length; ++j) {
					if (searchTexts[j].indexOf(keyWord) != -1) {
						return true
					}
				}
				return false
			}
		}
	}
	playListItemsTable.scrollToRowByDataKey(playListItemsTable.selectedDataKey, true)
}
function searchTotallist_onKeyUp() {
	if (event.keyCode == 13) {
		totalList_Search()
	}
}
function searchPlayList_onKeyUp() {
	if (event.keyCode == 13) {
		playListTable_Search()
	}
}
function searchPlayListItems_onKeyUp() {
	if (event.keyCode == 13) {
		playListItemsTable_Search()
	}
}
function totalList_copyTitle(list) {
	let options = list.selectedOptions
	let text = ''
	for (let i = 0; i < options.length; ++i) {
		text += videoClipList[options[i].value].title
		text += '\n'
	}
	if (text.length == 0) {
		return
	}
	const t = document.createElement("textarea");
	document.body.appendChild(t);
	t.value = text;
	t.select();
	document.execCommand('copy');
	document.body.removeChild(t);
	list.focus()
}
function list_onKeyDown(list) {
	if (event.keyCode == 17) {
	} else if (event.keyCode == 67) {
		totalList_copyTitle(list)
	}
}
function list_onKeyUp(list) {
	if (event.keyCode == 17) {
	}
}
function totalList_onKeyDown() {
	if (event.keyCode == 13 && showPlaylist.checked) {
		totalList_addSelectedToPlaylist()
	} else {
		list_onKeyDown(videoClipTable)
	}
}
function videoControl_oninput(value) {
	videoControl.isChanging = true
	//console.log(value)
}
function videoControl_onchange(value) {
	const state = player_getPlayerState()
	if (state == YT.PlayerState.PLAYING || state == YT.PlayerState.PAUSED) {
		player.seekTo(value, true)
		LastVideoTime = value
	}
	videoControl.isChanging = false
	//console.log('changed:'+value)
}
function suffleButton_onClick() {
	if (currentViewContext) {
		currentViewContext.shuffled = !currentViewContext.shuffled
	}
	playList_shuffle()
	refreshControlPanel()
}
function modeButton_onClick() {
	modePlayList = (modePlayList + 1) % 3
	refreshControlPanel()
}
function individualVolume_save(key, relVolume) {
	const curVolume = individualVolumeMap.get(key)
	if (curVolume != relVolume) {
		individualVolumeMap.set(key, relVolume)
		console.log('individualVolume_save' + ';key:' + key + ';relVolume:' + relVolume)
		volume_save()
	}
}
function volumeControl_update(value) {
	if (individualVolume.checked && currentVideoClip) {
		if (individualVolumeControl.value != value) {
			individualVolumeControl.value = value
			individualVolumeText.innerHTML = value + "%"
			const relVolume = Number(value) - Number(volumeControl.value)
			individualVolume_save(currentVideoClip.key, relVolume)
		}
	} else if (volumeControl.value != value) {
		volumeControl.value = value
		individualVolumeControl.value = value
		volumeText.innerHTML = value + "%"
		individualVolumeText.innerHTML = value + "%"
	}
}
function volumeControl_set(value) {
	if (individualVolume.checked && currentVideoClip) {
		const relVolume = individualVolumeMap.get(currentVideoClip.key)
		if (relVolume != undefined) {
			volumeText.innerHTML = value + "%"
			value = Number(value) + relVolume
			individualVolumeControl.value = value
			individualVolumeText.innerHTML = value + "%"
			player.setVolume(value)
		}
	} else {
		player.setVolume(value)
		individualVolumeControl.value = value
		volumeText.innerHTML = value + "%"
		individualVolumeText.innerHTML = value + "%"
	}
}
function volumeControl_oninput(value) {
	volumeControl.isChanging = true
	volumeControl_set(value)
}
function volumeControl_onchange(value) {
	volumeControl.isChanging = false
	volumeControl_set(value)
}
function volumeControl_onWheel(value) {
	let volume = player_getVolume()
	if (individualVolume.checked && currentVideoClip) {
		const relVolume = individualVolumeMap.get(currentVideoClip.key)
		if (relVolume != undefined) {
			volume -= relVolume
		}
	}
	let newVolume = volume - Math.sign(value) * 5
	newVolume = newVolume < 0 ? 0 : newVolume > 100 ? 100 : newVolume
	volumeControl.value = newVolume
	volumeControl_set(newVolume)
	event.preventDefault()
}
function individualVolumeControl_set(value) {
	if (individualVolume.checked && currentVideoClip) {
		player.setVolume(value)
		let relVolume = Number(value) - Number(volumeControl.value)
		individualVolume_save(currentVideoClip.key, relVolume)
		individualVolumeText.innerHTML = value + "%"
	}
}
function individualVolumeControl_oninput(value) {
	volumeControl.isChanging = true
	individualVolumeControl_set(value)
}
function individualVolumeControl_onchange(value) {
	volumeControl.isChanging = false
	individualVolumeControl_set(value)
}
function individualVolumeControl_onWheel(value) {
	let newVolume = player_getVolume() - Math.sign(value) * 5
	newVolume = newVolume < 0 ? 0 : newVolume > 100 ? 100 : newVolume
	individualVolumeControl_set(newVolume)
	event.preventDefault()
}
function playListTable_moveToFront() {
	playListTable.moveSelectionToFront()
	playListTable.focus()
	setDataChanged()
}
function playListTable_moveToBack() {
	playListTable.moveSelectionToBack()
	playListTable.focus()
	setDataChanged()
}
function playListTable_moveUp() {
	playListTable.moveSelectedItemUp()
	playListTable.focus()
	setDataChanged()
}
function playListTable_moveDown() {
	playListTable.moveSelectedItemDown()
	playListTable.focus()
	setDataChanged()
}
function playList_saveCheckboxes() {
	const playList = currentViewContext.data
	playList.shuffle = playList_checkBoxShuffle.checked
	playList.entirePlay = playList_checkBoxPlayEntireList.checked
	setDataChanged()
}
function playList_updateCheckboxes() {
	const playList = currentViewContext.data
	playList_checkBoxShuffle.checked = playList.shuffle
	playList_checkBoxPlayEntireList.checked = playList.entirePlay
}
function individualVolume_onClick() {
	if (currentVideoClip) {
		if (individualVolume.checked) {
			individualVolumeMap.set(currentVideoClip.key, 0)
			individualVolumeControl.disabled = false
			volume_save()
		} else {
			individualVolumeMap.delete(currentVideoClip.key)
			individualVolumeControl.disabled = true
			volume_save()
			volumeControl_set(volumeControl.value)
		}
	} else {
		individualVolume.checked = false
	}
}
function exportList() {
	exportData = {}
	exportData["playListData"] = playList_getJson()
	exportData["individualVolumeData"] = volume_getJson()
	exportData["settings"] = settings_getJson()
	exportimportDialogEdit.value = JSON.stringify(exportData)
	//const DataStr = JSON.stringify(exportData)
	//const encoder = new TextEncoder();
	//const DataBinary = encoder.encode(DataStr);
	//const DataBinaryStr = ArrayToString(DataBinary);
	//const exportStr = base64UrlEncode(DataBinaryStr);
	// const RevexportStr = base64UrlDecode(exportStr);
	// const ReverseDataBinary = StringToArray(RevexportStr);
	// const decoder = new TextDecoder();
	// const ReverseDataStr = decoder.decode(ReverseDataBinary);
	
	//const url = window.location.origin + window.location.pathname + '?a=' + exportStr;
	//window.history.pushState({}, null, '?a=' + exportStr)
	//exportimportDialogEdit.value = url
	exportimportDialog.onclose = function() {
		if (exportimportDialog.returnValue == 'ok') {
		}
	}
	if (typeof exportimportDialog.showModal === "function") {
		exportimportDialog.showModal();
	} else {
		alert("The <dialog> API is not supported by this browser");
	}
}
function importList() {
	exportimportDialogEdit.value = ''
	exportimportDialog.onclose = function() {
		if (exportimportDialog.returnValue == 'ok') {
			playListTable_deleteAll()

			let importData = {
				"playListData" : {},
				"individualVolumeData" : {},
				"settings" : {}
			};
			
			try {
				let Text = exportimportDialogEdit.value
				importData = JSON.parse(Text)
			} catch(err) {
			}
			localStorage.setItem("watamePlayer_PlayList", JSON.stringify(importData["playListData"]))
			localStorage.setItem("watamePlayer_Volumes", JSON.stringify(importData["individualVolumeData"]))
			localStorage.setItem("watamePlayer_settings", JSON.stringify(importData["settings"]))

			readData();
		}
	}
	if (typeof exportimportDialog.showModal === "function") {
		exportimportDialog.showModal();
	} else {
		alert("The <dialog> API is not supported by this browser");
	}
}
		</script>
	</head>
	<body onload="init()">
		<div style="max-width:100%;max-height:100%;display:flex;flex-direction:column;">
			<div style="flex:none">
				<input type="button" onClick="exportList()" value="Export"/>
				<input type="button" onClick="importList()" value="Import"/>
				<label for="showTotallist" style="cursor:pointer"><input id="showTotallist" type="checkbox" checked="true" onClick="updateDivVisible()" style="cursor:pointer">TotalList</label>
				<label for="showPlaylist" style="cursor:pointer"><input id="showPlaylist" type="checkbox" onClick="updateDivVisible()" style="cursor:pointer">PlayList</label>
				<label for="showPlaylistItems" style="cursor:pointer"><input id="showPlaylistItems" type="checkbox" onClick="updateDivVisible()" style="cursor:pointer">PlayListItems</label>
				<label for="showClipTableURL" style="cursor:pointer"><input id="showClipTableURL" type="checkbox" onClick="updateDivVisible()" style="cursor:pointer">ClipSpreadSheets</label>
				[Manual Video <a href="https://www.youtube.com/watch?v=f6Nvl9tysug" target="_blank">KR</a> / <a href="https://www.youtube.com/watch?v=hi8T21HbMHA" target="_blank">JP</a>]
			</div>
			<div id="divClipSpreadSheet" style="flex:none;display:flex;flex-direction: column;">
				<div style="display:flex">
					<button onClick="settings_save()">Save&Refresh</button>
					<button onClick="settings_newURL()">New</button>
				</div>
				<div id="divClipSpreadSheetURL" style="flex:none; display:flex; flex-direction:column;">
				</div>
			</div>
			<div style="flex-grow: 1;flex-shrink: 1;flex-basis: auto;overflow: hidden;display:flex;flex-direction:column;">
				<div id="divTotallist" style="flex: 1 1 500px; overflow: hidden; display: none; flex-direction: column; margin-bottom: 10px;">
					<div style="flex:none;display:flex;flex-direction:column;">
						<div style="flex:none;display:flex">
							<div style="flex:none">
								[TotalList]
							</div>
								<input style="flex:1" type="search" id="searchTotallist" onKeyUp="searchTotallist_onKeyUp()">
							<div style="flex:none">
								<button onClick="totalList_Search()">Search</button>
								<input id="totalListSearchCaseInsensitive" type="checkbox" checked="true">CaseInsensitive</input>
							</div>
						</div>
						<div style="flex:none">
							<input type="button" onClick="totalList_playVideo(videoClipTable.selectedDataIndex)" value="Play"/>
							<input type="button" onClick="totalList_selectAll()" value="Select All"/>
							<input type="button" onClick="totalList_clearAll()" value="Clear All"/>
							<input type="button" onClick="totalList_modify()" value="Batch Edit"/>
							<input type="button" onClick="totalList_addToPlaylist(true)" value="Add selected clips to PlayListItems"/>
							<input type="button" onClick="totalList_makePlayListPanel(true)" value="Make PlayList with selected clips"/>
							<input type="button" onClick="totalList_makeGroupedPlayListPanel(true)" value="Make Grouped PlayList with selected clips"/>
						</div>
					</div>
					<div style="overflow: hidden;flex: 1;display: flex;">
						<div id="totalList"></div>
					</div>
				</div>
				<div id="divPlaylistPanel" style="flex: 1 1 500px; overflow: hidden; display: none; flex-direction: column; margin-bottom: 10px;">
					<div style="flex:none">
						<div>
							[PlayList]
							<input type="button" onClick="playList_open(playListTable.getDataByKey(playListTable.selectedDataKey))" value="Open"/>
							<input type="button" onClick="playList_selectAll()" value="Select All"/>
							<input type="button" onClick="playList_clearAll()" value="Clear All"/>
							<input type="button" onClick="playList_newPanel()" value="New"/>
							<input type="button" onClick="playList_editPanel()" value="Edit"/>
							<input type="button" onClick="playList_clonePanel()" value="Clone"/>
							<input type="button" onClick="playListTable_modify()" value="Batch Edit"/>
							<input type="button" onClick="playListTable_deleteSelected()" value="Delete"/>
							<input type="button" onClick="playListTable_deleteAll()" value="Delete All"/>
							<input type="button" onClick="playListTable_moveToFront()" value="Move to front"/>
							<input type="button" onClick="playListTable_moveToBack()" value="Move to back"/>
							<input type="button" onClick="playListTable_moveUp()" value="Move up"/>
							<input type="button" onClick="playListTable_moveDown()" value="Move down"/>
							<input type="button" onClick="playList_addSelectedToPlayListItems()" value="Add selected to PlayListItems"/>
						</div>
						<div style="display:flex">
							<input style="flex:1" type="search" id="playListButton_search" onKeyUp="searchPlayList_onKeyUp()">
							<div style="flex:none">
								<button onClick="playListTable_Search()">Search</button>
								<input id="playListSearchCaseInsensitive" type="checkbox" checked="true">CaseInsensitive</input>
							</div>
						</div>
					</div>
					<div style="flex:1;overflow: hidden;display: flex;">
						<div id="playList"></div>
					</div>
				</div>
				<div id="divPlaylistItemsPanel" style="flex: 1 1 500px; overflow: hidden; display: none; flex-direction: column; margin-bottom: 10px;">
					<div style="flex:none">
					<div id="divViewPath"></div>
						<div>
							<input type="button" onClick="playListItemsTable.scrollToRowByDataKey(currentViewContext.currentPlayingItem.key, true)" value="ScrollTo"/>
							<input type="button" onClick="playListItemsTable_selectAll()" value="Select All"/>
							<input type="button" onClick="playListItemsTable_clearAll()" value="Clear All"/>
							<input type="button" onClick="playListItemsTable_play(playListItemsTable.selectedDataKey)" value="Play"/>
							<input type="button" onClick="playListItemsTable_playOrOpen(playListItemsTable.selectedDataKey, false)" value="Open"/>
							<input type="button" onClick="playListItemsTable_deleteSelected()" value="Delete"/>
							<input type="button" onClick="playListItemsTable_deleteAll()" value="Delete All"/>
							<input type="button" onClick="playListItemsTable_moveToFront()" value="Move to front"/>
							<input type="button" onClick="playListItemsTable_moveToBack()" value="Move to back"/>
							<input type="button" onClick="playListItemsTable_moveUp()" value="Move up"/>
							<input type="button" onClick="playListItemsTable_moveDown()" value="Move down"/>
							<input type="button" onClick="playListItemsTable_modify()" value="Batch Edit"/>
							<label for="playList_checkBoxShuffle" style="cursor:pointer"><input id="playList_checkBoxShuffle" type="checkbox" style="cursor:pointer" onClick="playList_saveCheckboxes()">Shuffle</label>
							<label for="playList_checkBoxPlayEntireList" style="cursor:pointer"><input id="playList_checkBoxPlayEntireList" type="checkbox" style="cursor:pointer" onClick="playList_saveCheckboxes()">PlayAll</label>
						</div>
						<div style="display:flex">
							<input style="flex:1" type="search" id="playListItemsButton_search" onKeyUp="searchPlayListItems_onKeyUp()">
							<div style="flex:none">
								<button onClick="playListItemsTable_Search()">Search</button>
								<input id="playListItemsSearchCaseInsensitive" type="checkbox" checked="true">CaseInsensitive</input>
							</div>
						</div>
					</div>
					<div style="flex:1;overflow: hidden;display: flex;">
						<div id="playListDetail"></div>
					</div>
				</div>
			</div>
			<div style="flex:none;">
				<div id="divPlayPath"></div>
				<input type="range" id="videoControl" oninput="videoControl_oninput(this.value)" onchange="videoControl_onchange(this.value)" style="width:100%">
				<div style="display:flex; flex-direction: column;padding-bottom:4px">
					<div style="display:flex;">
						<button id="prevButton" onClick="prevButton_onClick()" style="font-size:24px;width:50px;height:50px;" title="Previous"></button>
						<button id="playButton" onClick="playButton_onClick()" style="font-size:24px;width:50px;height:50px;"></button>
						<button id="nextButton" onClick="nextButton_onClick()" style="font-size:24px;width:50px;height:50px;" title="Next"></button>
						<button id="suffleButton" style="font-size:24px;width:50px;height:50px;" onclick="suffleButton_onClick()"><label id="suffleIcon" style="opacity: .4;">ðŸ”€</label></button>
						<button id="modeButton" style="font-size:24px;width:50px;height:50px;" onclick="modeButton_onClick()"><label id="modeIcon" style="opacity: .4;">ðŸ”</label></button>
					</div>
					<div style="padding-left: 4px;display: flex;">
						<div style="display: flex;flex-direction: column;align-items: flex-end;">
						<label>Volume</label>
							<label for="individualVolume" style="cursor:pointer"><input id="individualVolume" type="checkbox" style="cursor:pointer" onClick="individualVolume_onClick()">Individual</label>
						</div>
						<div style="display: flex;flex-direction: column;align-items: stretch;">
							<div style="display: flex;">
								<input type="range" id="volumeControl" oninput="volumeControl_oninput(this.value)" onchange="volumeControl_onchange(this.value)" onwheel="volumeControl_onWheel(event.deltaY)">
								<label id="volumeText">?</label>
							</div>
							<div style="display: flex;">
								<input type="range" id="individualVolumeControl" disabled="disabled" oninput="individualVolumeControl_oninput(this.value)" onchange="individualVolumeControl_onchange(this.value)" onwheel="individualVolumeControl_onWheel(event.deltaY)">
								<label id="individualVolumeText">?</label>
							</div>
						</div>
					</div>
					<div>
						<label id="currentSong" style="font-weight:bold;"></label>
						<br>
						<label id="currentOrder"></label>
					</div>
				</div>
			</div>
		</div>
		<script src="https://www.youtube.com/iframe_api"></script>
		<div id="divPlayer">
			<div id="player"></div>
		</div>
		<dialog id="playListDialog">
		  <form method="dialog">
			<div style="display: flex;">
				<div style="display: flex; flex-direction: column; align-items: flex-end; padding-right: 2px;">
					<label>category:</label>
					<label>Date:</label>
					<label>Track Name:</label>
					<label>Original Artist:</label>
					<label>Covered By:</label>
				</div>
				<div style="display: flex; flex-direction: column; align-items: stretch;">
					<input type="text" id="playListDialog_Category">
					<input type="text" id="playListDialog_Date">
					<input type="text" id="playListDialog_TrackName">
					<input type="text" id="playListDialog_OriginalArtist">
					<input type="text" id="playListDialog_CoveredBy">
					<label for="playListDialog_cbShuffle" style="cursor:pointer"><input id="playListDialog_cbShuffle" type="checkbox" style="cursor:pointer">Shuffle</label>
					<label for="playListDialog_cbPlayEntireVideo" style="cursor:pointer"><input id="playListDialog_cbPlayEntireVideo" type="checkbox" style="cursor:pointer">PlayAll</label>
				</div>
			</div>
			<menu>
				<div style="display: flex; flex-direction: row-reverse;">
					<button value="ok" style="margin-left: 4px;">OK</button>
					<button value="cancel">Cancel</button>
				</div>
			</menu>
		  </form>
		</dialog>
		<dialog id="totalListHeaderSelectDialog">
		  <form method="dialog">
			<p style="font-weight:bold;">Group By Headers</p>
			<div style="display: flex; flex-direction: column; align-items: stretch;">
				<label for="totalListHeaderSelect_cbCategory" style="cursor:pointer"><input id="totalListHeaderSelect_cbCategory" type="checkbox" style="cursor:pointer">Category</label>
				<label for="totalListHeaderSelect_cbDate" style="cursor:pointer"><input id="totalListHeaderSelect_cbDate" type="checkbox" style="cursor:pointer">Date</label>
				<label for="totalListHeaderSelect_cbTitle" style="cursor:pointer"><input id="totalListHeaderSelect_cbTitle" type="checkbox" style="cursor:pointer">Track Name</label>
				<label for="totalListHeaderSelect_cbOriSinger" style="cursor:pointer"><input id="totalListHeaderSelect_cbOriSinger" type="checkbox" style="cursor:pointer">Original Artist</label>
				<label for="totalListHeaderSelect_cbSinger" style="cursor:pointer"><input id="totalListHeaderSelect_cbSinger" type="checkbox" style="cursor:pointer">Covered By</label>
			</div>
			<p style="font-weight:bold;">Represent Text</p>
			<div style="display: flex;">
				<div style="display: flex; flex-direction: column; align-items: flex-end; padding-right: 2px;">
					<label>Category:</label>
					<label>Track Name:</label>
					<label>Original Artist:</label>
					<label>Covered By:</label>
				</div>
				<div style="display: flex; flex-direction: column; align-items: stretch;">
					<input type="text" id="totalListHeaderSelect_CommonCategory">
					<input type="text" id="totalListHeaderSelect_CommonTrackName">
					<input type="text" id="totalListHeaderSelect_CommonOriginalArtist">
					<input type="text" id="totalListHeaderSelect_CommonCoveredBy">
				</div>
			</div>
			<p style="font-weight:bold;">Default Property</p>
			<div style="display: flex; flex-direction: column; align-items: stretch;">
				<label for="totalListHeaderSelect_cbShuffle" style="cursor:pointer"><input id="totalListHeaderSelect_cbShuffle" type="checkbox" style="cursor:pointer">Shuffle</label>
				<label for="totalListHeaderSelect_cbPlayEntireVideo" style="cursor:pointer"><input id="totalListHeaderSelect_cbPlayEntireVideo" type="checkbox" style="cursor:pointer">PlayAll</label>
			</div>
			<p style="font-weight:bold;">Make Option</p>
			<div style="display: flex; flex-direction: column; align-items: stretch;">
				<label for="totalListHeaderSelect_cbAppendIfExists" style="cursor:pointer"><input id="totalListHeaderSelect_cbAppendIfExists" type="checkbox" style="cursor:pointer" onclick="totalListHeaderSelect_cbAppendToFront.disabled = !totalListHeaderSelect_cbAppendIfExists.checked">Append to PlayList if exists</label>
				<label for="totalListHeaderSelect_cbAppendToFront" style="cursor:pointer"><input id="totalListHeaderSelect_cbAppendToFront" type="checkbox" style="cursor:pointer" checked="true" disabled="true">Append to Front</label>
			</div>
			<menu>
				<div style="display: flex; flex-direction: row-reverse;">
					<button value="ok" style="margin-left: 4px;">OK</button>
					<button value="cancel">Cancel</button>
				</div>
			</menu>
		  </form>
		</dialog>
		<dialog id="exportimportDialog">
			<form method="dialog">
			  <textarea id="exportimportDialogEdit" style="width: 400px; height: 200px;"></textarea>
			  <menu>
					<div style="display: flex; flex-direction: row-reverse;">
						<button value="ok" style="margin-left: 4px;">OK</button>
						<button value="cancel">Cancel</button>
					</div>
				</menu>
			</form>
		</dialog>
		<dialog id="modifyPlayListDetailDialog">
			<form method="dialog">
				<menu>
					<div style="display: flex;">
						<div style="display: flex; flex-direction: column; align-items: flex-end; padding-right: 2px;">
							<label>ShufflePriority:</label>
						</div>
						<div style="display: flex; flex-direction: column; align-items: stretch;">
							<input type="text" id="modifyPlayListDetailDialog_ShufflePriority">
						</div>
					</div>
					<div style="display: flex; flex-direction: row-reverse;">
						<button value="ok" style="margin-left: 4px;">OK</button>
						<button value="cancel">Cancel</button>
					</div>
				</menu>
			</form>
		</dialog>
		<dialog id="modifyVideoClipDialog">
			<form method="dialog">
				<menu>
					<div style="display: flex;">
						<div style="display: flex; flex-direction: column; align-items: flex-end; padding-right: 2px;">
							<label>IndividualVolume:</label>
						</div>
						<div style="display: flex; flex-direction: column; align-items: stretch;">
							<input type="text" id="modifyVideoClipDialog_IndividualVolume">
						</div>
					</div>
					<div style="display: flex; flex-direction: row-reverse;">
						<button value="ok" style="margin-left: 4px;">OK</button>
						<button value="cancel">Cancel</button>
					</div>
				</menu>
			</form>
		</dialog>
		<dialog id="modifyPlayListDialog">
			<form method="dialog">
				<menu>
					<div style="display: flex;">
						<div style="display: flex; flex-direction: column; align-items: flex-end; padding-right: 2px;">
							<label>Shuffle:</label>
							<label>PlayAll:</label>
						</div>
						<div style="display: flex; flex-direction: column; align-items: stretch;">
							<select id="modifyPlayListDialog_Shuffle">
								<option value="" selected="selected">Skip</option>
								<option value="1" >True</option>
								<option value="0" >False</option>
							</select>
							<select id="modifyPlayListDialog_PlayEntireVideo">
								<option value="" selected="selected">Skip</option>
								<option value="1" >True</option>
								<option value="0" >False</option>
							</select>
						</div>
					</div>
					<div style="display: flex; flex-direction: row-reverse;">
						<button value="ok" style="margin-left: 4px;">OK</button>
						<button value="cancel">Cancel</button>
					</div>
				</menu>
			</form>
		</dialog>
	</body>
</html>
